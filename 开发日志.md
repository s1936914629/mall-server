# 1. 关于此项目

此项目是一个自营性质电商类型的项目。

当前目标是设计后台管理相关功能。

# 2. 关于项目的开发流程

开发项目的标准流程应该有：需求分析、可行性分析、总体设计、详细设计等。

在具体开发时，应该先创建数据库、数据表，然后创建项目进行开发。

# 3. 创建数据库与数据表

创建`mall_pms`数据库：

```mysql
CREATE DATABASE mall_pms;
```

在此数据库中创建数据表：

```mysql
-- 数据库：mall_pms

-- 相册表：创建数据表
drop table if exists pms_album;
create table pms_album
(
    id           bigint unsigned auto_increment comment '记录id',
    name         varchar(50)      default null comment '相册名称',
    description  varchar(255)     default null comment '相册简介',
    sort         tinyint unsigned default 0 comment '自定义排序序号',
    gmt_create   datetime         default null comment '数据创建时间',
    gmt_modified datetime         default null comment '数据最后修改时间',
    primary key (id)
) comment '相册' charset utf8mb4;

-- 相册表：为相册名称字段添加索引
create index idx_album_name on pms_album (name);

-- 图片表：创建数据表
drop table if exists pms_picture;
create table pms_picture
(
    id           bigint unsigned auto_increment comment '记录id',
    album_id     bigint unsigned   default null comment '相册id',
    url          varchar(255)      default null comment '图片url',
    description  varchar(255)      default null comment '图片简介',
    width        smallint unsigned default null comment '图片宽度，单位：px',
    height       smallint unsigned default null comment '图片高度，单位：px',
    is_cover     tinyint unsigned  default 0 comment '是否为封面图片，1=是，0=否',
    sort         tinyint unsigned  default 0 comment '自定义排序序号',
    gmt_create   datetime          default null comment '数据创建时间',
    gmt_modified datetime          default null comment '数据最后修改时间',
    primary key (id)
) comment '图片' charset utf8mb4;

-- 品牌表：创建数据表
drop table if exists pms_brand;
create table pms_brand
(
    id                     bigint unsigned auto_increment comment '记录id',
    name                   varchar(50)      default null comment '品牌名称',
    pinyin                 varchar(50)      default null comment '品牌名称的拼音',
    logo                   varchar(255)     default null comment '品牌logo的URL',
    description            varchar(255)     default null comment '品牌简介',
    keywords               varchar(255)     default null comment '关键词列表，各关键词使用英文的逗号分隔',
    sort                   tinyint unsigned default 0 comment '自定义排序序号',
    sales                  int unsigned     default 0 comment '销量（冗余）',
    product_count          int unsigned     default 0 comment '商品种类数量总和（冗余）',
    comment_count          int unsigned     default 0 comment '买家评论数量总和（冗余）',
    positive_comment_count int unsigned     default 0 comment '买家好评数量总和（冗余）',
    enable                 tinyint unsigned default 0 comment '是否启用，1=启用，0=未启用',
    gmt_create             datetime         default null comment '数据创建时间',
    gmt_modified           datetime         default null comment '数据最后修改时间',
    primary key (id)
) comment '品牌' charset utf8mb4;

-- 品牌表：为品牌名称字段添加索引
create index idx_brand_name on pms_brand (name);

-- 类别表：创建数据表
drop table if exists pms_category;
create table pms_category
(
    id           bigint unsigned auto_increment comment '记录id',
    name         varchar(50)      default null comment '类别名称',
    parent_id    bigint unsigned  default 0 comment '父级类别id，如果无父级，则为0',
    depth        tinyint unsigned default 1 comment '深度，最顶级类别的深度为1，次级为2，以此类推',
    keywords     varchar(255)     default null comment '关键词列表，各关键词使用英文的逗号分隔',
    sort         tinyint unsigned default 0 comment '自定义排序序号',
    icon         varchar(255)     default null comment '图标图片的URL',
    enable       tinyint unsigned default 0 comment '是否启用，1=启用，0=未启用',
    is_parent    tinyint unsigned default 0 comment '是否为父级（是否包含子级），1=是父级，0=不是父级',
    is_display   tinyint unsigned default 0 comment '是否显示在导航栏中，1=启用，0=未启用',
    gmt_create   datetime         default null comment '数据创建时间',
    gmt_modified datetime         default null comment '数据最后修改时间',
    primary key (id)
) comment '类别' charset utf8mb4;

-- 类别表：为类别名称字段添加索引
create index idx_category_name on pms_category (name);

-- 品牌类别关联表：创建数据表
drop table if exists pms_brand_category;
create table pms_brand_category
(
    id           bigint unsigned auto_increment comment '记录id',
    brand_id     bigint unsigned default null comment '品牌id',
    category_id  bigint unsigned default null comment '类别id',
    gmt_create   datetime        default null comment '数据创建时间',
    gmt_modified datetime        default null comment '数据最后修改时间',
    primary key (id)
) comment '品牌与类别关联' charset utf8mb4;

-- 属性表：创建数据表
drop table if exists pms_attribute;
create table pms_attribute
(
    id                 bigint unsigned auto_increment comment '记录id',
    template_id        bigint unsigned  default null comment '所属属性模版id',
    name               varchar(50)      default null comment '属性名称',
    description        varchar(255)     default null comment '简介（某些属性名称可能相同，通过简介补充描述）',
    type               tinyint unsigned default 0 comment '属性类型，1=销售属性，0=非销售属性',
    input_type         tinyint unsigned default 0 comment '输入类型，0=手动录入，1=单选，2=多选，3=单选（下拉列表），4=多选（下拉列表）',
    value_list         varchar(255)     default null comment '备选值列表',
    unit               varchar(50)      default null comment '计量单位',
    sort               tinyint unsigned default 0 comment '自定义排序序号',
    is_allow_customize tinyint unsigned default 0 comment '是否允许自定义，1=允许，0=禁止',
    gmt_create         datetime         default null comment '数据创建时间',
    gmt_modified       datetime         default null comment '数据最后修改时间',
    primary key (id)
) comment '属性' charset utf8mb4;

-- 属性模版表：创建数据表
drop table if exists pms_attribute_template;
create table pms_attribute_template
(
    id           bigint unsigned auto_increment comment '记录id',
    name         varchar(50)      default null comment '属性模版名称',
    pinyin       varchar(50)      default null comment '属性模版名称的拼音',
    keywords     varchar(255)     default null comment '关键词列表，各关键词使用英文的逗号分隔',
    sort         tinyint unsigned default 0 comment '自定义排序序号',
    gmt_create   datetime         default null comment '数据创建时间',
    gmt_modified datetime         default null comment '数据最后修改时间',
    primary key (id)
) comment '属性模版' charset utf8mb4;

-- 属性模版表：为属性模版名称字段添加索引
create index idx_attribute_template_name on pms_attribute_template (name);

-- 类别与属性模版关联表：创建数据表
drop table if exists pms_category_attribute_template;
create table pms_category_attribute_template
(
    id                    bigint unsigned auto_increment comment '记录id',
    category_id           bigint unsigned default null comment '类别id',
    attribute_template_id bigint unsigned default null comment '属性模版id',
    gmt_create            datetime        default null comment '数据创建时间',
    gmt_modified          datetime        default null comment '数据最后修改时间',
    primary key (id)
) comment '类别与属性模版关联' charset utf8mb4;

-- SPU（Standard Product Unit）表：创建数据表
drop table if exists pms_spu;
create table pms_spu
(
    id                     bigint unsigned not null comment '记录id',
    name                   varchar(50)      default null comment 'SPU名称',
    type_number            varchar(50)      default null comment 'SPU编号',
    title                  varchar(255)     default null comment '标题',
    description            varchar(255)     default null comment '简介',
    list_price             decimal(10, 2)   default null comment '价格（显示在列表中）',
    stock                  int unsigned     default 0 comment '当前库存（冗余）',
    stock_threshold        int unsigned     default 0 comment '库存预警阈值（冗余）',
    unit                   varchar(50)      default null comment '计件单位',
    brand_id               bigint unsigned  default null comment '品牌id',
    brand_name             varchar(50)      default null comment '品牌名称（冗余）',
    category_id            bigint unsigned  default null comment '类别id',
    category_name          varchar(50)      default null comment '类别名称（冗余）',
    attribute_template_id  bigint unsigned  default null comment '属性模版id',
    album_id               bigint unsigned  default null comment '相册id',
    pictures               varchar(500)     default null comment '组图URLs，使用JSON数组表示',
    keywords               varchar(255)     default null comment '关键词列表，各关键词使用英文的逗号分隔',
    tags                   varchar(255)     default null comment '标签列表，各标签使用英文的逗号分隔，原则上最多3个',
    sales                  int unsigned     default 0 comment '销量（冗余）',
    comment_count          int unsigned     default 0 comment '买家评论数量总和（冗余）',
    positive_comment_count int unsigned     default 0 comment '买家好评数量总和（冗余）',
    sort                   tinyint unsigned default 0 comment '自定义排序序号',
    is_deleted             tinyint unsigned default 0 comment '是否标记为删除，1=已删除，0=未删除',
    is_published           tinyint unsigned default 0 comment '是否上架（发布），1=已上架，0=未上架（下架）',
    is_new_arrival         tinyint unsigned default 0 comment '是否新品，1=新品，0=非新品',
    is_recommend           tinyint unsigned default 0 comment '是否推荐，1=推荐，0=不推荐',
    is_checked             tinyint unsigned default 0 comment '是否已审核，1=已审核，0=未审核',
    check_user             varchar(50)      default null comment '审核人（冗余）',
    gmt_check              datetime         default null comment '审核通过时间（冗余）',
    gmt_create             datetime         default null comment '数据创建时间',
    gmt_modified           datetime         default null comment '数据最后修改时间',
    primary key (id)
) comment 'SPU（Standard Product Unit）' charset utf8mb4;

-- SPU详情表：创建数据表
drop table if exists pms_spu_detail;
create table pms_spu_detail
(
    id           bigint unsigned auto_increment comment '记录id',
    spu_id       bigint unsigned default null comment 'SPU id',
    detail       text            default null comment 'SPU详情，应该使用HTML富文本，通常内容是若干张图片',
    gmt_create   datetime        default null comment '数据创建时间',
    gmt_modified datetime        default null comment '数据最后修改时间',
    primary key (id)
) comment 'SPU详情' charset utf8mb4;

-- SKU（Stock Keeping Unit）表：创建数据表
drop table if exists pms_sku;
create table pms_sku
(
    id                     bigint unsigned not null comment '记录id',
    spu_id                 bigint unsigned  default null comment 'SPU id',
    title                  varchar(255)     default null comment '标题',
    bar_code               varchar(255)     default null comment '条型码',
    attribute_template_id  bigint unsigned  default null comment '属性模版id',
    specifications         varchar(2500)    default null comment '全部属性，使用JSON格式表示（冗余）',
    album_id               bigint unsigned  default null comment '相册id',
    pictures               varchar(500)     default null comment '组图URLs，使用JSON格式表示',
    price                  decimal(10, 2)   default null comment '单价',
    stock                  int unsigned     default 0 comment '当前库存',
    stock_threshold        int unsigned     default 0 comment '库存预警阈值',
    sales                  int unsigned     default 0 comment '销量（冗余）',
    comment_count          int unsigned     default 0 comment '买家评论数量总和（冗余）',
    positive_comment_count int unsigned     default 0 comment '买家好评数量总和（冗余）',
    sort                   tinyint unsigned default 0 comment '自定义排序序号',
    gmt_create             datetime         default null comment '数据创建时间',
    gmt_modified           datetime         default null comment '数据最后修改时间',
    primary key (id)
) comment 'SKU（Stock Keeping Unit）' charset utf8mb4;

-- SKU规格参数表（存储各SKU的属性与值，即规格参数）：创建数据表
drop table if exists pms_sku_specification;
create table pms_sku_specification
(
    id              bigint unsigned auto_increment comment '记录id',
    sku_id          bigint unsigned  default null comment 'SKU id',
    attribute_id    bigint unsigned  default null comment '属性id',
    attribute_name  varchar(50)      default null comment '属性名称',
    attribute_value varchar(50)      default null comment '属性值',
    unit            varchar(10)      default null comment '自动补充的计量单位',
    sort            tinyint unsigned default 0 comment '自定义排序序号',
    gmt_create      datetime         default null comment '数据创建时间',
    gmt_modified    datetime         default null comment '数据最后修改时间',
    primary key (id)
) comment 'SKU数据' charset utf8mb4;

-- -------------------------- --
-- 以下是插入测试数据及一些测试访问 --
-- -------------------------- --

-- 品牌表：插入测试数据
insert into pms_brand (name, pinyin, description, keywords, enable)
values ('华为', 'huawei', '华为专注网络设备三十年', '华为,huawei,mate,magicbook', 1),
       ('小米', 'xiaomi', '小米，为发烧而生', '小米,xiaomi,发烧', 1),
       ('苹果', 'pingguo', '苹果，全球知名品牌', '苹果,apple,pingguo,iphone,mac', 1);

-- 类别表：插入测试数据
insert into pms_category (name, parent_id, depth, is_parent, keywords, enable, is_display)
values ('手机 / 运营商 / 数码', 0, 1, 1, null, 1, 1),
       ('手机通讯', 1, 2, 1, '手机,电话', 1, 1),
       ('智能手机', 2, 3, 0, null, 1, 1),
       ('非智能手机', 2, 3, 0, null, 1, 1),
       ('电脑 / 办公', 0, 1, 1, null, 1, 1),
       ('电脑整机', 5, 2, 1, '电脑,计算机,微机,服务器,工作站', 1, 1),
       ('电脑配件', 5, 2, 1, '配件,组装,CPU,内存,硬盘', 1, 1),
       ('笔记本', 6, 3, 0, '电脑,笔记本,微机,便携', 1, 1),
       ('台式机 / 一体机', 6, 3, 0, '台式机,一体机', 1, 1);

-- 品牌类别表：插入测试数据
insert into pms_brand_category (brand_id, category_id)
values (1, 3),
       (2, 3),
       (3, 3),
       (1, 8),
       (2, 8),
       (3, 8),
       (1, 9),
       (3, 9);

-- 关联测试查询：各品牌有哪些类别的产品
select pms_brand_category.id, pms_brand.name, pms_category.name
from pms_brand_category
         left join pms_brand
                   on pms_brand_category.brand_id = pms_brand.id
         left join pms_category
                   on pms_brand_category.category_id = pms_category.id
order by pms_brand.pinyin;

-- 属性表：插入测试数据
insert into pms_attribute (name, description, type, input_type, value_list, unit, is_allow_customize)
values ('屏幕尺寸', '智能手机屏幕尺寸', 0, 1, '6.1,6.3', '英寸', 1),
       ('屏幕尺寸', '笔记本电脑屏幕尺寸', 0, 1, '14,15', '英寸', 1),
       ('颜色', '智能手机颜色', 0, 1, '黑色,金色,白色', null, 1),
       ('颜色', '衬衣颜色', 0, 1, '白色,蓝色,灰色,黑色', null, 1),
       ('运行内存', '智能手机运行内存', 0, 1, '4,8,16', 'GB', 1),
       ('CPU型号', '智能手机CPU型号', 0, 1, '骁龙870,骁龙880', null, 1),
       ('机身毛重', '智能手机机身毛重', 0, 0, null, 'g', 0),
       ('机身存储', '智能手机机身存储', 0, 1, '64,128,256,512', 'GB', 0),
       ('操作系统', '智能手机操作系统', 0, 1, 'Android,iOS', null, 0),
       ('操作系统', '电脑操作系统', 0, 1, '无,Windows 7,Windows 10,Ubuntu,Mac OS', null, 0);

-- 属性模版表：插入测试数据
insert into pms_attribute_template (name, pinyin, keywords)
values ('智能手机', 'zhinengshouji', '手机'),
       ('服装-上身', 'fuzhuang', '服装,上衣'),
       ('服装-裤子', 'fuzhuang', '服装,裤'),
       ('笔记本电脑', 'bijibendiannao', '电脑,笔记本'),
       ('台式电脑', 'taishidiannao', '电脑,台式电脑,台式机');

-- 相册表：插入测试数据
insert into pms_album (name, description)
values ('iPhone 13', null),
       ('Mi 11 Ultra', null);

-- 图片表：插入测试数据
insert into pms_picture (album_id, url, description, width, height)
values (1, '模拟数据：iPhone 13图片URL-1', null, 1024, 768),
       (1, '模拟数据：iPhone 13图片URL-2', null, 1024, 768),
       (1, '模拟数据：iPhone 13图片URL-3', null, 1024, 768),
       (1, '模拟数据：iPhone 13图片URL-4', null, 1024, 768),
       (1, '模拟数据：iPhone 13图片URL-5', null, 1024, 768),
       (2, '模拟数据：Mi 11 Ultra图片URL-1', null, 1024, 768),
       (2, '模拟数据：Mi 11 Ultra图片URL-2', null, 1024, 768),
       (2, '模拟数据：Mi 11 Ultra图片URL-3', null, 1024, 768),
       (2, '模拟数据：Mi 11 Ultra图片URL-4', null, 1024, 768),
       (2, '模拟数据：Mi 11 Ultra图片URL-5', null, 1024, 768);

-- SPU表：插入测试数据
insert into pms_spu (id, name, type_number, title, description, list_price, stock, stock_threshold, unit, brand_id,
                     brand_name, category_id, category_name, keywords, tags)
values (202112010000001, 'iPhone 13', 'A2404', '苹果手机iPhone 13（A2404）', '2021年新款，全网首发',
        5199.99, 5000, 20, '部', 3, '苹果', 3, '智能手机', 'ip13,iPhone13,苹果13', '20w快充,NFC,无线充电'),
       (202112010000002, '小米11 Ultra', 'M112021', '小米11 Ultra（M112021）', '2021年最新旗舰机',
        5899.99, 8000, 20, '部', 2, '小米', 3, '智能手机', 'mi11,xiaomi11,ultra', '67w快充,1亿像素,5000毫安电池');

-- SPU详情表：插入测试数据
insert into pms_spu_detail (spu_id, detail)
values (1, '<div>iPhone 13的详情HTML</div>'),
       (2, '<div>小米11 Ultra的详情HTML</div>');

-- SKU（Stock Keeping Unit）表：插入测试数据
insert into pms_sku (id, spu_id, title, attribute_template_id, specifications, price, stock, stock_threshold)
values (202112010000001, 2, '2021年新款，小米11 Ultra黑色512G，16G超大内存120Hz高刷67w快充', 1,
        '{"attributes":[{"id":1,"name":"屏幕尺寸","value":"6.1寸"},{"id":3,"name":"颜色","value":"黑色"},{"id":5,"name":"运行内存","value":"16GB"}]}',
        6999.99, 3000, 50),
       (202112010000002, 2, '2021年新款，小米11 Ultra白色512G，8G超大内存120Hz高刷67w快充', 1,
        '{"attributes":[{"id":1,"name":"屏幕尺寸","value":"6.1寸"},{"id":3,"name":"颜色","value":"白色"},{"id":5,"name":"运行内存","value":"8GB"}]}',
        6499.99, 3000, 50);

-- SKU规格参数表（存储各SKU的属性与值，即规格参数）：插入测试数据
insert into pms_sku_specification (sku_id, attribute_id, attribute_name, attribute_value, unit)
values (1, 1, '屏幕尺寸', '6.1', '寸'),
       (1, 3, '颜色', '黑色', null),
       (1, 5, '运行内存', '16', 'GB'),
       (2, 1, '屏幕尺寸', '6.1', '寸'),
       (2, 3, '颜色', '白色', null),
       (2, 5, '运行内存', '8', 'GB');

-- 查看数据表结构
desc pms_album;
desc pms_picture;
desc pms_category;
desc pms_brand;
desc pms_brand_category;
desc pms_attribute;
desc pms_attribute_template;
desc pms_spu;
desc pms_spu_detail;
desc pms_sku;
desc pms_sku_specification;
```

# 4. 关于Project与Module

Project：项目 / 工程

Module：模块

在较大规范的项目开发中，可能会把代码区分为多个Module进行开发，即某1个Project中可能有多个Module，各Module允许独立开发、独立运行，并且，可以在Project或某个父级Module中，对其子级的依赖项等部分的内容进行统筹管理。

需要注意：并不是每个Module都是可以独立运行的，在开发实践中，如果某些代码是多个Module都需要使用的，可以把这部分代码写在专门的Module中，其它Module依赖这个专门的Module即可（就像添加某个依赖项一样）。

当使用Project结合多个Module开发时，Project基本上不需要编写任何与功能相关的代码，只需要配置好`pom.xml`即可。

# 5. 创建Project

使用Spring Boot创建向导来创建Project，相关参数：

- Spring Boot父工程版本：2.5.4
- groupId：cn.org.sqx
- artifactId：mall-server
- version：1.0-SNAPSHOT

由于Project并不需要运行（也不能运行），对于各依赖项，只需要管理即可，并不需要实际的添加！

在Project的`pom.xml`中，如果直接使用`<dependencies>`节点配置依赖项，则每个Module可以直接使用这些依赖项！但是，不推荐这样使用，因为Spring Boot的许多依赖都是支持自动配置的，如果在Module中自带了不需要使用的依赖项，反而容易导致错误，即使不会导致错误，也会因为自带了不需要使用的依赖项而导致最终的目标文件大。

通常，会将依赖项的代码放在`<dependencyManagement>`节点中，则在`<dependencyManagement>`之下的依赖项都不会默认出现在当前Project及各子级的Module中，其主要作用是配置各依赖项的版本，接下来，无论是在当前Project还是子级Module中，使用`<dependencies>`添加依赖项时，都可以不指定`<version>`节点来配置版本，默认使用的就是在`<dependencyManagement>`中配置的版本。

为了在当前`pom.xml`集中管理各依赖的版本号，推荐在`<properties>`中添加一些“变量”，用于配置版本号，在`<dependencyManagement>`和`<dependencies>`中添加依赖时，都可以引用此处的“变量”表示版本，例如：

```xml
<properties>
    <java.version>1.8</java.version>
    <spring-boot.version>2.5.9</spring-boot.version>
    <mybatis-boot.version>2.2.2</mybatis-boot.version>
    <mysql.version>8.0.30</mysql.version>
    <lombok.version>1.18.22</lombok.version>
</properties>
```

另外，由于Project并不实现的编写需要运行的功能代码，更不会直接编译打包或运行，所以，在Project的`pom.xml`中的`<build>`节点是不必要的！

最后，把Project的`src`全部删除！

# 6. 商品管理模块项目

应该在Project下创建某个Module，用于开发商品管理相关的功能，为了便于过渡到后续将要使用的微服务架构（需要将业务逻辑层的接口声明在专门的Module中，便于被其它微服务Module依赖），商品管理的Module需要再细分为2个，所以，目前项目结构应该是：

```
mall-server[project]
	mall-product
		mall-product-webapi
		mall-product-service
```

当存在Project和Module的“父子关系”或后续可能存在Module与Module的“父子关系”时，应该在父级的`pom.xml`中添加：

```xml
<packaging>pom</packaging>
```

并且，在父级的`pom.xml`中，通过`<modules>`节点配置各子级Module，例如：

```xml
<modules>
	<module>mall-product</module>
</modules>
```

创建Module的操作步骤为：在`mall-server`下创建`mall-product`，再在`mall-product`下创建`mall-product-webapi`。

当Project和各Module创建出来后，调整各`pom.xml`文件。

最终，`mall-server`根级Project的`pom.xml`为：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <!-- Spring Boot父项目 -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.5.9</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <!-- 当前项目的信息 -->
    <groupId>cn.org.sqx</groupId>
    <artifactId>mall-server</artifactId>
    <version>1.0-SNAPSHOT</version>

    <!-- 聚合项目中的父级Project或父级Module都应该做以下配置 -->
    <packaging>pom</packaging>

    <!-- 当前Project的各子级Module -->
    <modules>
        <module>mall-product</module>
    </modules>

    <!-- 属性配置，主要配置各依赖项的版本号对应的“变量” -->
    <properties>
        <java.version>1.8</java.version>
        <spring-boot.version>2.5.9</spring-boot.version>
        <mybatis-boot.version>2.2.2</mybatis-boot.version>
        <mysql.version>8.0.28</mysql.version>
        <lombok.version>1.18.22</lombok.version>
        <druid.version>1.1.20</druid.version>
    </properties>

    <!-- 依赖管理，主要管理各依赖项的版本，使得子级Module添加依赖时不必指定版本 -->
    <dependencyManagement>
        <dependencies>
            <!-- Spring Boot Validation：验证请求参数的基本格式 -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-validation</artifactId>
                <version>${spring-boot.version}</version>
            </dependency>
            <!-- Spring Boot Web：支持Spring MVC -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-web</artifactId>
                <version>${spring-boot.version}</version>
            </dependency>
            <!-- Mybatis Spring Boot：Mybatis及对Spring Boot的支持 -->
            <dependency>
                <groupId>org.mybatis.spring.boot</groupId>
                <artifactId>mybatis-spring-boot-starter</artifactId>
                <version>${mybatis-boot.version}</version>
            </dependency>
            <!-- MySQL -->
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
                <scope>runtime</scope>
                <version>${mysql.version}</version>
            </dependency>
            <!-- Lombok -->
            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
                <optional>true</optional>
                <version>${lombok.version}</version>
            </dependency>
            <!-- Druid数据库连接池 -->
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>druid</artifactId>
                <version>${druid.version}</version>
            </dependency>
            <!-- Spring Boot Test：测试 -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-test</artifactId>
                <scope>test</scope>
                <version>${spring-boot.version}</version>
            </dependency>
        </dependencies>
    </dependencyManagement>

</project>
```

而`mall-product`的`pom.xml`为：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <!-- 父级项目 -->
    <parent>
        <groupId>cn.org.sqx</groupId>
        <artifactId>mall-server</artifactId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <!-- 当前项目的信息 -->
    <groupId>cn.org.sqx</groupId>
    <artifactId>mall-product</artifactId>
    <version>1.0-SNAPSHOT</version>

    <!-- 聚合项目中的父级Project或父级Module都应该做以下配置 -->
    <packaging>pom</packaging>

    <!-- 当前Project的各子级Module -->
    <modules>
        <module>mall-product-webapi</module>
    </modules>

</project>
```

最后，在`mall-product-webapi`的`pom.xml`为：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <!-- 父级项目 -->
    <parent>
        <groupId>cn.org.sqx</groupId>
        <artifactId>mall-product</artifactId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <!-- 当前项目的信息 -->
    <groupId>cn.org.sqx</groupId>
    <artifactId>mall-product-webapi</artifactId>
    <version>1.0-SNAPSHOT</version>

    <!-- 当前项目需要使用的依赖项 -->
    <dependencies>
        <!-- Spring Boot Validation：验证请求参数的基本格式 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <!-- Spring Boot Web：支持Spring MVC -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!-- Mybatis Spring Boot：Mybatis及对Spring Boot的支持 -->
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
        </dependency>
        <!-- MySQL -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <scope>runtime</scope>
        </dependency>
        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <!-- Druid数据库连接池 -->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
        </dependency>
        <!-- Spring Boot Test：测试 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>
```

# 7. 关于编写代码

根据已经添加的数据表，目前此项目中需要管理的数据类型大致有：

- 品牌
- 类别
- 图片
- 相册
- 属性
- 属性模版
- SPU
- SKU
- 相关的关联表

首先，需要分析以上数据类型的开发先后顺序，部分数据之间存在依赖与被依赖关系，例如SKU肯定归属于某个SPU，在开发时，必须先开发SPU，再开发SKU，同理，必须先开发品牌，才可以开发SPU……

根据分析，必要的顺序为：(品牌 | 类别 | (相册 >>> 图片) | (属性模板 >>> 属性)) >>> SPU >>> SKU。

分析出必要顺序后，存在一些不需要严格区分顺序的数据类型，例如以上的品牌和类型，实际的开发顺序可以是先简单、后复杂，例如品牌数据通常比类别数据更加简单，则应该先开发品牌数据的管理，再开发类别数据的管理。

本次学习过程中，先开发类别，至于品牌，可自行课后完成！

当确定了需要处理类别的数据时，需要规划需要开发此数据的哪些管理功能，例如：添加类别、启用类别、禁用类别、修改类别的基本信息、根据id查询、根据parent_id查询列表……

以上管理类别数据的功能，开发顺序应该是：添加类别 >>> (根据id查询 | 根据parent_id查询列表) >>> (启用类别 | 禁用类别 | 修改类别的基本信息)

# 8. 类别管理--添加类别--持久层

## 8.1. 配置

由于目前是本项目第1次开发持久层，必须先完成必要的配置，包括：

- 连接到数据库（配置连接数据库的参数）
- 使用`@MapperScan`指定接口所在的包
- 配置`mybatis.mapper-locations`指定XML文件的位置

应该先在`mall-product-webapi`的`src\main\resources`下创建`application-dev.properties`文件，在其中添加连接数据库的参数：

```properties
# 连接数据库的配置信息
spring.datasource.url=jdbc:mysql://localhost:3306/mall_pms?useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai
spring.datasource.username=root
spring.datasource.password=root
```

然后，在`application.properties`中添加配置：

```properties
# 激活Profile配置
spring.profiles.active=dev
# 连接数据库的固定配置
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource

# Mybatis的XML文件位置
mybatis.mapper-locations=classpath:mapper/*.xml
```

然后，需要在`src/main/resources`下自行创建`mapper`文件夹，与以上配置对应。

还需要自行创建配置类，用于配置Mapper接口文件所在的包，则在`cn.org.sqx.mall.product.webapi`下创建`mapper`子包，并在`cn.org.sqx.mall.product.webapi`下创建`config.MybatisConfiguration`配置类，进行配置：

```java
package cn.org.sqx.mall.product.webapi.config;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@MapperScan("cn.org.sqx.mall.product.webapi.mapper")
public class MybatisConfiguration {

}
```

完成后，可以尝试测试连接到数据库，则在`src/test/java`下找到默认即存在的测试类，编写并执行测试：

```java
package cn.org.sqx.mall.product.webapi;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import javax.sql.DataSource;

@SpringBootTest
class mallProductWebapiApplicationTests {

    @Autowired
    DataSource dataSource;

    @Test
    void contextLoads() {
    }
    
    @Test
    void () {
        Assertions.assertDoesNotThrow(() -> {
            dataSource.getConnection();
        });
    }

}
```

执行整个测试，应该能够通过测试。

## 8.2. 规划需要执行的SQL语句

此次需要执行的是“增加类别”，其数据操作的本质是向`pms_category`表中插入数据，需要执行的SQL语句大致是：

```mysql
insert into pms_category (除了id以外的字段的列表) values (与字段列表匹配的各字段值);
```

具体表现为：

```mysql
insert into pms_category (name, parent_id, depth, keywords, sort, icon, enable, is_parent, is_display, gmt_create, gmt_modified) values (值列表);
```

另外，还应该考虑在“添加类别”时，是否需要执行相关的检查，因为这些检查很可能是通过查询数据库来实现的，则在持久层也需要实现这些功能！

暂定规则“类别的名称不允许重复”，则后续在Service层进行处理时，应该先根据尝试添加的类别的名称进行查询，如果查询结果为`null`，表示此名称对应的类别尚不存在，将允许添加，如果查询结果不为`null`，表示此名称对应的类别已经存在，将不允许添加！

要实现以上检查的效果，需要执行的SQL语句可以是：

```mysql
select * from pms_category where name=?;
```

或者：

```mysql
select count(*) from pms_category where name=?;
```

以上2种做法，第1种做法的查询效率相对较低，或者说性能消耗略高，第2种做法的查询性能消耗更低，但是，第1种做法的查询可能具有复用性，而第2种做法的查询的复用性相对较低。

暂定可以使用以上第1种做法。

## 8.3. 接口与抽象方法

在插入数据之前，需要先创建“类别”对应的实体类型，而这个实体类型不能直接创建在`mall-product-webapi`模块中，而是应该创建在另一个新的模块中，以便于其它各模块都可以使用到相同的实体类型（例如商品的实体类型，在商品管理模块和订单管理模块中都将需要使用）。

在Project中创建新的子模块`mall-pojo`，创建出来后，需要：

- 修改父项目
  - 在`mall-pojo`的`pom.xml`中修改
  - 在根项目的`pom.xml`中添加新的`<module>`
- 确定所需的依赖项
  - 需要依赖`lombok`，其它依赖项暂时不需要
- 删除不要的代码
  - 在`pom.xml`中只需要：父项目、当前项目的信息、依赖项
  - 启动类是不需要的，必须删除（因为没有依赖Spring Boot，不删除则报错）
  - `src/main/resource`是不需要的（包含其下的`application.properties`），可以删除
  - `src/test`是不需要的，必须删除（否则默认的测试类会报错）

然后，在`cn.org.sqx.mall.pojo.entity`包下创建`Category`类：

```java
package cn.org.sqx.mall.pojo.entity;

import lombok.Data;

import java.io.Serializable;
import java.time.LocalDateTime;

@Data
public class Category implements Serializable {

    private Long id;
    private String name;
    private Long parentId;
    private Integer depth;
    private String keywords;
    private Integer sort;
    private String icon;
    private Integer enable;
    private Integer isParent;
    private Integer isDisplay;
    private LocalDateTime gmtCreate;
    private LocalDateTime gmtModified;

}
```

为了实现其它Module可以依赖`mall-pojo`，应该先在根级Project的`pom.xml`中对`mall-pojo`实现依赖管理：

```xml
<!-- ===== 其它原有代码 ===== -->

<!-- 属性配置，主要配置各依赖项的版本号对应的“变量” -->
<properties>
    <!-- ===== 其它原有代码 ===== -->
    <mall.version>1.0-SNAPSHOT</mall.version> <!-- 新增 -->
</properties>

<!-- 依赖管理，主要管理各依赖项的版本，使得子级Module添加依赖时不必指定版本 -->
<dependencyManagement>
    <dependencies>
        <!-- mall POJO -->
        <dependency>
            <groupId>cn.org.sqx</groupId>
            <artifactId>mall-pojo</artifactId>
            <version>${mall.version}</version>
        </dependency>
        
        <!-- ===== 其它原有代码 ===== -->
```

然后，在`mall-product-webapi`的`pom.xml`中添加依赖：

```xml
<!-- ===== 其它原有代码 ===== -->

<!-- 当前项目需要使用的依赖项 -->
<dependencies>
    <!-- mall POJO -->
    <dependency>
        <groupId>cn.org.sqx</groupId>
        <artifactId>mall-pojo</artifactId>
    </dependency>
    
    <!-- ===== 其它原有代码 ===== -->
```

至此，在`mall-product-webapi`中就已经成功的依赖了`mall-pojo`，可以理解为`mall-pojo`已经成为`mall-product-webapi`的一部分。

在`cn.org.sqx.mall.product.webapi.mapper`包下创建`CategoryMapper`接口，并在接口上添加`@Repository`注解（主要是避免IntelliJ IDEA在自动装配时的误判错误），并在接口中添加抽象方法：

```java
/**
 * 处理“类别”数据的持久层接口
 */
@Repository
public interface CategoryMapper {

    /**
     * 插入“类别”数据
     * @param category 类别
     * @return 受影响的行数
     */
    int insert(Category category);
    
    // 查询--待定

}
```

## 8.4. 配置SQL语句

从其它位置（或项目）中复制粘贴`CategoryMapper.xml`到`mall-product-webapi`的`src/main/resources/mapper`下。

关于`CategoryMapper.xml`文件的配置：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="cn.org.sqx.mall.product.webapi.mapper.CategoryMapper">

    <!-- int insert(Category category); -->
    <insert id="insert" useGeneratedKeys="true" keyProperty="id">
        insert into pms_category (
            name, parent_id, depth, keywords, sort,
            icon, enable, is_parent, is_display, gmt_create,
            gmt_modified
        ) values (
            #{name}, #{parentId}, #{depth}, #{keywords}, #{sort},
            #{icon}, #{enable}, #{isParent}, #{isDisplay}, #{gmtCreate},
            #{gmtModified}
        )
    </insert>

</mapper>
```

## 8.5. 测试

先在`src/test`下创建`resources`文件夹，并在此文件夹中创建`truncate.sql`脚本，此脚本将用于重置数据表：

```mysql
truncate pms_category;
```

然后，在`src/test/java`的根包下创建`mapper.CategoryMapperTests`，编写并执行测试：

```java
package cn.org.sqx.mall.product.webapi.mapper;

import cn.org.sqx.mall.pojo.entity.Category;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.jdbc.Sql;

@SpringBootTest
public class CategoryMapperTests {

    @Autowired
    CategoryMapper mapper;

    @Test
    @Sql("classpath:truncate.sql")
    public void testInsert() {
        // 测试数据
        Category category = new Category();
        category.setName("手机");
        // 断言不会抛出异常
        assertDoesNotThrow(() -> {
            int rows = mapper.insert(category);
            assertEquals(1, rows);
            assertEquals(1, category.getId());
        });
    }

}
```



## 8.6. 接口与抽象方法

此前需要执行的SQL语句大致是：

```mysql
select id from pms_category where name=?;
```

在`mall-pojo`的根包下创建`vo.CategorySimpleVO`类，用于封装以上查询结果：

```java
@Data
public class CategorySimpleVO implements Serializable {
    private Long id;
}
```

在`mall-product-webapi`的`CategoryMapper`接口中添加抽象方法：

```java
CategorySimpleVO getByName(String name);
```

## 8.7. 配置SQL语句

在`mall-product-webapi`的`CategoryMapper.xml`中添加配置：

```xml
<!-- CategorySimpleVO getByName(String name); -->
<select id="getByName" resultMap="SimpleResultMap">
    select id from pms_category where name=#{name}
</select>

<resultMap id="SimpleResultMap" type="cn.org.sqx.mall.pojo.vo.CategorySimpleVO">
    <id column="id" property="id" />
</resultMap>
```

## 8.8. 测试

在`mall-product-webapi`的`src\test\resources`下创建`insert_data.sql`文件，用于插入测试数据：

```mysql
insert into pms_category (name) value ('类别001'), ('类别002');
```

然后，在`CategoryMapperTests`中添加测试方法：

```java
@Test
@Sql({"classpath:truncate.sql", "classpath:insert_data.sql"})
public void testGetByNameSuccessfully() {
    // 测试数据
    String name = "类别001";
    // 断言不会抛出异常
    assertDoesNotThrow(() -> {
        // 执行查询
        CategorySimpleVO category = mapper.getByName(name);
        // 断言查询结果不为null
        assertNotNull(category);
    });
}

@Test
@Sql({"classpath:truncate.sql"})
public void testGetByNameFailBecauseNotFound() {
    // 测试数据
    String name = "类别999";
    // 断言不会抛出异常
    assertDoesNotThrow(() -> {
        // 执行查询
        CategorySimpleVO category = mapper.getByName(name);
        // 断言查询结果为null
        assertNull(category);
    });
}
```

完成后，执行整个测试类（将执行此类中所有测试方法），应该全部通过测试。

# 9. 类别管理--添加类别--业务逻辑层

## 9.1. 接口与抽象方法

在使用Dubbo的微服务架构中，需要将业务逻辑层的接口声明在专门的Module中，便于被其它微服务Module依赖，所以，先在`mall-product`下创建新的Module，名为`mall-product-service`，创建参数：

- Group：`cn.org.sqx`
- Artifact：`mall-product-service`
- Package Name：`cn.org.sqx.mall.product.service`

首先，应该调用新Module的`pom.xml`如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <!-- 父级项目 -->
    <parent>
        <groupId>cn.org.sqx</groupId>
        <artifactId>mall-product</artifactId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <!-- 当前项目的信息 -->
    <groupId>cn.org.sqx</groupId>
    <artifactId>mall-product-service</artifactId>
    <version>1.0-SNAPSHOT</version>

    <!-- 当前项目需要使用的依赖项 -->
    <dependencies>
        <!-- mall POJO -->
        <dependency>
            <groupId>cn.org.sqx</groupId>
            <artifactId>mall-pojo</artifactId>
        </dependency>
    </dependencies>

</project>
```

然后，在`mall-product`的`pom.xml`中补充此子级Module：

```xml
<!-- 当前Project的各子级Module -->
<modules>
    <module>mall-product-webapi</module>
    <module>mall-product-service</module> <!-- 新增 -->
</modules>
```

接下来，需要删除不必要的文件：

- 启动类
- `src\main\resources`及其下的配置文件
- `src\test`

接下来，需要创建接口并添加抽象方法，方法的参数应该是封装的对象（因为一个`String`或`Long`等简单数据不足以完成添加类别的操作），则先在`mall-pojo`的根包下创建`dto.CategoryAddNewDTO`类，并在类中添加必要的属性：

```java
package cn.org.sqx.mall.pojo.dto;

import lombok.Data;

import java.io.Serializable;

@Data
public class CategoryAddNewDTO implements Serializable {

    private String name;
    private Long parentId;
    private String keywords;
    private Integer sort;
    private String icon;
    private Integer isDisplay;

}
```

然后，在`mall-product-service`中，在`cn.org.sqx.mall.product.service`下创建`ICategoryService`接口：

```java
public interface ICategoryService {
    void addNew(CategoryAddNewDTO categoryAddNewDTO);
}
```

## 9.2. 实现

在`mall-product-service`中只存放业务逻辑层的接口，而业务逻辑层的实现类仍在`mall-product-webapi`中，所以，需要在`mall-product-webapi`中依赖`mall-product-service`。

先在Project的`pom.xml`中添加对`mall-product-service`的依赖管理：

```xml
<!-- ===== 原有其它代码 ===== -->

<!-- 依赖管理，主要管理各依赖项的版本，使得子级Module添加依赖时不必指定版本 -->
<dependencyManagement>
    <dependencies>
        <!-- mall Product Service -->
        <dependency>
            <groupId>cn.org.sqx</groupId>
            <artifactId>mall-product-service</artifactId>
            <version>${mall.version}</version>
        </dependency>
        
        <!-- ===== 原有其它代码 ===== -->
```

然后，在`mall-product-webapi`中添加依赖：

```xml
<!-- ===== 原有其它代码 ===== -->

<!-- 当前项目需要使用的依赖项 -->
<dependencies>
    <!-- mall Product Service -->
    <dependency>
        <groupId>cn.org.sqx</groupId>
        <artifactId>mall-product-service</artifactId>
    </dependency>
    
    <!-- ===== 原有其它代码 ===== -->
```

在`cn.org.sqx.mall.product.webapi`下创建`service.CategoryServiceImpl`类，此类应该实现`ICategoryService`接口，此类还应该添加`@Service`注解：

```java
package cn.org.sqx.mall.product.webapi.service;

import cn.org.sqx.mall.pojo.dto.CategoryAddNewDTO;
import cn.org.sqx.mall.product.service.ICategoryService;
import org.springframework.stereotype.Service;

@Service
public class CategoryServiceImpl implements ICategoryService {
    
    @Override
    public void addNew(CategoryAddNewDTO categoryAddNewDTO) {
    }
    
}
```

关于以上业务的实现分析：

```java
@Autowired
private CategoryMapper categoryMapper;

// 注意：需要创建异常
// 注意：需要在CategoryMapper中补充getById()方法，至少返回：depth
// 注意：需要在CategoryMapper中补充updateIsParentById()方法
public void addNew(CategoryAddNewDTO categoryAddNewDTO) {
    // 从参数中取出尝试添加的类别的名称
    // 调用categoryMapper.getByName()方法查询
    // 判断查询结果是否不为null
    // 是：抛出ServiceException
    
    // 从参数中取出父级类别的id：parentId
    // 判断parentId是否为0
    // 是：此次尝试添加的是一级类别，没有父级类别，则当前depth >>> 1
    // 否：此次尝试添加的不是一级类别，则应该存在父级类别，调用categoryMapper.getById()方法查询父级类别的信息
    // -- 判断查询结果是否为null
    // -- 是：抛出ServiceException
    // -- 否：当前depth >>> 父级depth + 1

    // 创建Category对象
    // 调用BeanUtils.copyProperties()将参数对象中的属性值复制到Category对象中
    // 补全Category对象中的属性值：depth >>> 前序运算结果
    // 补全Category对象中的属性值：enable >>> 1（默认即启用）
    // 补全Category对象中的属性值：isParent >>> 0
    // 补全Category对象中的属性值：gmtCreate, gmtModified >>> LocalDateTime.now()
    // 调用categoryMapper.insert(Category)插入类别数据，获取返回的受影响的行数
    // 判断返回的受影响的行数是否不为1
    // 是：抛出ServiceException
    
    // 判断父级类别的isParent是否为0
    // 是：调用categoryMapper.updateIsParentById()方法，将父级类别的isParent修改为1，获取返回的受影响的行数
    // 判断返回的受影响的行数是否不为1
    // 是：抛出ServiceException
}
```

要实现以上业务，需要先在持久层完成“根据id查询类别信息”的功能，则在`CategorySimpleVO`中添加`private Integer depth;`属性（原`getByName()`方法对应的查询也作对应的修改，虽然不是必须的）。

然后，还需要在`CategorySimpleVO`中补充`private Integer isParent;`属性，并且，必须在接下的查询中，查出此值。

然后`CategeoryMapper`接口中添加：

```java
CategorySimpleVO getById(Long id);
```

然后在`CategoryMapper.xml`中配置以上方法映射的SQL：

```xml
<!-- CategorySimpleVO getById(Long id); -->
<select id="getById" resultMap="SimpleResultMap">
    select id, depth from pms_category where id=#{id}
</select>
```

完成后，还需要在`CategoryMapperTests`中添加2个测试，以检验以上功能是否正常运行：

```java
@Test
@Sql({"classpath:truncate.sql", "classpath:insert_data.sql"})
public void testGetByIdSuccessfully() {
    // 测试数据
    Long id = 1L;
    // 断言不会抛出异常
    assertDoesNotThrow(() -> {
        // 执行查询
        CategorySimpleVO category = mapper.getById(id);
        // 断言查询结果不为null
        assertNotNull(category);
    });
}

@Test
@Sql({"classpath:truncate.sql"})
public void testGetByIdFailBecauseNotFound() {
    // 测试数据
    Long id = -1L;
    // 断言不会抛出异常
    assertDoesNotThrow(() -> {
        // 执行查询
        CategorySimpleVO category = mapper.getById(id);
        // 断言查询结果为null
        assertNull(category);
    });
}
```

在`CategoryMapper`接口中添加：

```java
int updateIsParentById(@Param("id") Long id, @Param("isParent") Integer isParent);
```

然后在`CategoryMapper.xml`中配置以上方法映射的SQL：

```xml
<!-- int updateIsParentById(@Param("id") Long id, @Param("isParent") Integer isParent); -->
<update id="updateIsParentById">
    update pms_category set is_parent=#{isParent} where id=#{id}
</update>
```

完成后，还需要在`CategoryMapperTests`中添加2个测试，以检验以上功能是否正常运行：

```java
@Test
@Sql({"classpath:truncate.sql", "classpath:insert_data.sql"})
public void testUpdateIsParentByIdSuccessfully() {
    // 测试数据
    Long id = 1L;
    Integer isParent = 1;
    // 断言不会抛出异常
    assertDoesNotThrow(() -> {
        // 执行测试
        int rows = mapper.updateIsParentById(id, isParent);
        // 断言受影响的行数为1
        assertEquals(1, rows);
    });
}

@Test
@Sql({"classpath:truncate.sql"})
public void testUpdateIsParentByIdFailBecauseNotFound() {
    // 测试数据
    Long id = -1L;
    Integer isParent = 1;
    // 断言不会抛出异常
    assertDoesNotThrow(() -> {
        // 执行测试
        int rows = mapper.updateIsParentById(id, isParent);
        // 断言受影响的行数为0
        assertEquals(0, rows);
    });
}
```

在实现业务逻辑之前，还需要创建自定义的异常类型，由于后续还有不少需要被多个Module共同使用的类、接口等，所以，此异常类型和后续可能被共用的类、接口都应该放在一个公共的Module中，则在Project下创建`mall-common`这个新的Module，创建成功后，需要：

- 在`mall-common`中，修改`pom.xml`中的父项目
- 在`mall-common`中，在`pom.xml`删除依赖项
- 在`mall-common`中，在`pom.xml`删除`<build>`配置
- 在`mall-common`中，删除`src/test`
- 在`mall-common`中，删除`src/main/resources`
- 在`mall-common`中，删除启动类
- 在Project的`pom.xml`中，添加`<module>`
- 在Project的`pom.xml`中，添加对新Module的依赖管理
- 在`mall-product-webapi`中的`pom.xml`中，添加对`mall-common`的依赖

在`mall-common`的根包下创建`ex.ServiceException`类：

```java
public class ServiceException extends RuntimeException {
	// 暂时不加构造方法
}
```

然后，在`mall-product-webapi`中的`CategoryServiceImpl`中实现业务：

```java
package cn.org.sqx.mall.product.webapi.service;

import cn.org.sqx.mall.common.ex.ServiceException;
import cn.org.sqx.mall.pojo.dto.CategoryAddNewDTO;
import cn.org.sqx.mall.pojo.entity.Category;
import cn.org.sqx.mall.pojo.vo.CategorySimpleVO;
import cn.org.sqx.mall.product.service.ICategoryService;
import cn.org.sqx.mall.product.webapi.mapper.CategoryMapper;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

@Service
public class CategoryServiceImpl implements ICategoryService {

    @Autowired
    CategoryMapper categoryMapper;

    @Override
    public void addNew(CategoryAddNewDTO categoryAddNewDTO) {
        // 从参数中取出尝试添加的类别的名称
        String name = categoryAddNewDTO.getName();
        // 调用categoryMapper.getByName()方法查询
        CategorySimpleVO queryResult = categoryMapper.getByName(name);
        // 判断查询结果是否不为null
        if (queryResult != null) {
            // 是：抛出ServiceException
            throw new ServiceException();
        }

        // 从参数中取出父级类别的id：parentId
        Long parentId = categoryAddNewDTO.getParentId();
        // 判断parentId是否为0，当前尝试新增的类别的depth默认为1
        Integer depth = 1;
        CategorySimpleVO parentCategory = null;
        if (parentId != 0) {
            // 否：此次尝试添加的不是一级类别，则应该存在父级类别，调用categoryMapper.getById()方法查询父级类别的信息
            parentCategory = categoryMapper.getById(parentId);
            // -- 判断查询结果是否为null
            if (parentCategory == null) {
                // -- 是：抛出ServiceException
                throw new ServiceException();
            }
            // -- 否：当前depth >>> 父级depth + 1
            depth = parentCategory.getDepth() + 1;
        }

        // 创建Category对象
        Category category = new Category();
        // 调用BeanUtils.copyProperties()将参数对象中的属性值复制到Category对象中
        BeanUtils.copyProperties(categoryAddNewDTO, category);
        // 补全Category对象中的属性值：depth >>> 前序运算结果
        category.setDepth(depth);
        // 补全Category对象中的属性值：enable >>> 1（默认即启用）
        category.setEnable(1);
        // 补全Category对象中的属性值：isParent >>> 0
        category.setIsParent(0);
        // 补全Category对象中的属性值：gmtCreate, gmtModified >>> LocalDateTime.now()
        LocalDateTime now = LocalDateTime.now();
        category.setGmtCreate(now);
        category.setGmtModified(now);
        // 调用categoryMapper.insert(Category)插入类别数据，获取返回的受影响的行数
        int rows = categoryMapper.insert(category);
        // 判断返回的受影响的行数是否不为1
        if (rows != 1) {
            // 是：抛出ServiceException
            throw new ServiceException();
        }

        // 判断父级类别的isParent是否为0
        // 以下判断条件有部分多余，但不会报错
        if (parentId != 0 && parentCategory != null && parentCategory.getIsParent() == 0) {
            // 是：调用categoryMapper.updateIsParentById()方法，将父级类别的isParent修改为1，获取返回的受影响的行数
            rows = categoryMapper.updateIsParentById(parentId, 1);
            // 判断返回的受影响的行数是否不为1
            if (rows != 1) {
                // 是：抛出ServiceException
                throw new ServiceException();
            }
        }
    }

}
```

## 9.3. 测试

在`src/test/java`下的根包下创建`service.CategoryServiceTests`测试类，编写并执行测试：

```java
package cn.org.sqx.mall.product.webapi.service;

import cn.org.sqx.mall.common.ex.ServiceException;
import cn.org.sqx.mall.pojo.dto.CategoryAddNewDTO;
import cn.org.sqx.mall.product.service.ICategoryService;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.jdbc.Sql;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;

@SpringBootTest
public class CategoryServiceTests {

    @Autowired
    ICategoryService service;

    @Test
    @Sql("classpath:truncate.sql")
    public void testAddNewSuccessfully() {
        // 测试数据
        CategoryAddNewDTO category = new CategoryAddNewDTO();
        category.setName("大屏智能手机");
        category.setParentId(0L);
        category.setIcon("未上传类别图标");
        category.setKeywords("未设置关键字");
        category.setSort(88);
        category.setIsDisplay(1);
        // 断言不会抛出异常
        assertDoesNotThrow(() -> {
            // 执行测试
            service.addNew(category);
        });
    }

    @Test
    @Sql({"classpath:truncate.sql", "classpath:insert_data.sql"})
    public void testAddNewFailBecauseNameDuplicate() {
        // 测试数据
        CategoryAddNewDTO category = new CategoryAddNewDTO();
        category.setName("类别001");
        // 断言不会抛出异常
        assertThrows(ServiceException.class, () -> {
            // 执行测试
            service.addNew(category);
        });
    }

    @Test
    @Sql({"classpath:truncate.sql"})
    public void testAddNewFailBecauseParentNotFound() {
        // 测试数据
        CategoryAddNewDTO category = new CategoryAddNewDTO();
        category.setName("类别001");
        category.setParentId(-1L);
        // 断言不会抛出异常
        assertThrows(ServiceException.class, () -> {
            // 执行测试
            service.addNew(category);
        });
    }

}
```

# 10. 基于Spring JDBC的事务管理

事务：是一种能够保证同一个业务中多个写（增删改）操作要么全部成功，要么失败的机制！

在业务方法上添加`@Transactional`即可保证此方法是业务性（要么全部成功，要么全部失败）的。

在Spring JDBC中，处理事务的机制大致是：

```
开启事务：Begin
try {
    你的业务方法
    提交：Commit
} catch (RuntimeException e) {
    回滚：Rollback
}
```

所以，为了保证事务性，所有的写操作在执行之后，必须有某个判定为失败的标准，且判断定为失败后，必须抛出`RuntimeException`或其子孙类异常！

- Spring JDBC默认对`RuntimeException`进行回滚处理，有必要的话，也可以配置为其它异常类型

当需要方法是事务性的，可以使用`@Transactional`注解，此注解可以添加在： 

- 接口
  - 会使得此接口的实现类的所有实现方法都是事务性的
- 接口中的抽象方法上
  - 会使得此接口的实现类中，重写的此方法是事务性的
  - 只作用于当前方法
  - 如果接口上也配置了此注解，并且接口和抽象方法的注解均配置了参数，以方法上的配置为准
- 业务实现类
  - 会使得当前类中所有重写的方法都是事务性
    - 自定义的方法不会是事务性的
- 业务实现类中的方法
  - 不可以添加在自定义的（不是重写的接口的）方法上
    - 语法上，可以添加，但执行时，不允许

Spring JDBC是通过接口代理的方式进行事务管理，所以，只对接口中声明的方法有效！

通常，应该将`@Transactional`添加在接口中的抽象方法上（如果偷懒，或为了避免遗漏，也可以直接添加在接口上）。

目前，由于`mall-product-service`没有添加相关依赖，所以，并不能直接在接口中使用`@Transactional`注解（因为尚不可识别），则应该在此Module中添加依赖：

```xml
<!-- Mybatis Spring Boot：Mybatis及对Spring Boot的支持 -->
<!-- 仅需要保留spring-jdbc，使得业务接口可以使用@Transactional注解 -->
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <exclusions>
        <exclusion>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-autoconfigure</artifactId>
        </exclusion>
        <exclusion>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
        </exclusion>
        <exclusion>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis-spring</artifactId>
        </exclusion>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </exclusion>
        <exclusion>
            <groupId>com.zaxxer</groupId>
            <artifactId>HikariCP</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

# 11. 类别管理--添加类别--业务逻辑层

目前，在业务实现中，视为“错误”时始终抛出`ServiceException`，且没有任何异常信息，是不合理的！

在略大规模的项目中，“错误”的种类可能较大，如果为每一种“错误”都创建一个对应的异常，则需要创建的异常类型就比较多，但是，这些异常类除了名称不一样以外，几乎没有不同，所以，存在不利于管理和维护的问题。

其实，也可以只使用1个异常类型（或者少量异常类型），但是，每次抛出时，也需要明确的表示“是哪一种错误”，则可以在异常类型中添加“业务状态码”。

则首先需要业务状态码的类型，可以从前缀项目中复制`State`文件，例如：

```java
package cn.org.sqx.mall.common.web;

public enum State {

    OK(20000),
    ERR_CATEGORY_NAME_DUPLICATE(40100), // 客户端引起的--类别--名称冲突（被占用）
    ERR_CATEGORY_NOT_FOUND(40101), // 客户端引起的--类别--数据不存在（查询参数值不正确）
    ERR_INSERT(50000), // 服务端引起的--插入数据错误
    ERR_UPDATE(50001); // 服务端引起的--更新数据错误

    private Integer value;

    State(Integer value) {
        this.value = value;
    }

    public Integer getValue() {
        return value;
    }

}
```

然后，在ServiceException中，自定义构造方法，强制要求传入`State state`和`String message`参数，并且，为`State`类型参数提供公有的获取值的方法：


```java
public class ServiceException extends RuntimeException {
    private State state;
    
    public ServiceException(State state, String message) {
        super(message);
        if (state == null) {
            throw new IllegalArgumentException("使用ServiceException必须指定错误时的业务状态码！");
        }
        this.state  = state;
    }
    
    public State getState() {
        return state;
    }
}
```

在后续抛出异常时，应该传入`State state`和`String message`：

```java
throw new ServiceException(State.ERR_CATEGORY_NOT_FOUND, "添加类别失败，父级类别不存在！");
```

完成后，应该再次执行测试，以保证修改代码后，原有代码依然能正确运行。

# 12. 类别管理--添加类别--控制器层

## 12.1. 处理跨域（一次性配置）

在`mall-product-webapi`的根包下`config`包下创建`SpringMvcConfiguration`类，实现`WebMvcConfigururer`接口，重写其中的方法，以解决跨域问题：

```java
package cn.org.sqx.mall.product.webapi.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class SpringMvcConfiguration implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOriginPatterns("*")
                .allowedMethods("*")
                .allowedHeaders("*")
                .allowCredentials(true)
                .maxAge(3600);
    }

}
```

> 提示：以上代码从此前的案例中复制过来即可。

## 12.2. 控制器类与处理请求的方法

先将此前项目中的`JsonResult`复制到`mall-common`的根包下的`web`子包中（需要在`mall-common`中补充依赖`lombok`）。

在`mall-product-webapi`的根包下创建`controller.CategoryController`类，在类上添加`@RestController`和`@RequestMapping(value = "/categories", produces = "application/json; charset=utf-8")`这2个注解：

```java
@RestController
@RequestMapping(value = "/categories", produces = "application/json; charset=utf-8")
public class CategoryController {
    
}
```

然后，在类中添加处理请求的方法：

```java
@Autowired
private ICategoryService categoryService;

@PostMapping("/add-new")
public JsonResult<Void> addNew(CategoryAddNewDTO categoryAddNewDTO) {
    categoryService.addNew(categoryAddNewDTO);
    return JsonResult.ok();
}
```

## 12.3. 控制器层测试

在`mall-product-webapi`的测试的根包下创建`controller.CategoryControllerTests`测试类，编写并执行测试：

```java
@SpringBootTest
@AutoConfigureMockMvc
public class CategoryControllerTests {
    
    @Autowired
    MockMvc mockMvc;
    
    @Test
    @Sql("classpath:truncate.sql")
    public void testAddNewSuccessfully() throws Exception {
        // 准备测试数据，不需要封装，应该全部声明为String类型
        String name = "水果";
        String parentId = "0"; // 即使目标类型是Long，参数值也不要加L
        String keywords = "水果的关键字是啥";
        String sort = "66";
        String icon = "图标待定";
        String isDisplay = "1";
        // 请求路径，不需要写协议、服务器主机和端口号
        String url = "/categories/add-new";
        // 执行测试
        // 以下代码相对比较固定
        mockMvc.perform( // 执行发出请求
                MockMvcRequestBuilders.post(url) // 根据请求方式决定调用的方法
                .contentType(MediaType.APPLICATION_FORM_URLENCODED) // 请求数据的文档类型，例如：application/json; charset=utf-8
                .param("name", name) // 请求参数，有多个时，多次调用param()方法
                .param("parentId", parentId)
                .param("keywords", keywords)
                .param("icon", icon)
                .param("sort", sort)
            	.param("isDisplay", isDisplay)
                .accept(MediaType.APPLICATION_JSON)) // 接收的响应结果的文档类型，注意：perform()方法到此结束
                .andExpect( // 预判结果，类似断言
                        MockMvcResultMatchers
                                .jsonPath("state") // 预判响应的JSON结果中将有名为state的属性
                                .value(20000)) // 预判响应的JSON结果中名为state的属性的值，注意：andExpect()方法到此结束
                .andDo( // 需要执行某任务
                        MockMvcResultHandlers.print()); // 打印日志
    }
    
}
```

## 12.4. 处理异常

在`mall-common`中添加依赖项：

```xml
<!-- Spring Boot Web：支持Spring MVC -->
<!-- 需要使用到@RestControllerAdvice等注解 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </exclusion>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-json</artifactId>
        </exclusion>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

在`mall-common`根包下的`ex`包下创建`handler.GlobalExceptionHandler`，并在此类中处理异常：

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(ServiceException.class)
    public JsonResult<Void> handleServiceException(ServiceException ex) {
        return JsonResult.fail(ex.getState(), ex.getMessage());
    }

}
```

完成后，使用错误的测试数据时，会发现根本不会处理异常，是因为在`mall-product-webapi`中默认执行的组件扫描不会扫描到以上`GlobalExceptionHandler`所在的包，为了解决此问题，应该先在`mall-common`的根包下创建`config.mallCommonConfiguration`类，此类应该是配置类，且配置组件扫描：

```java
package cn.org.sqx.mall.common.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan("cn.org.sqx.mall.common.ex.handler")
public class mallCommonConfiguration {
}
```

然后，在`mall-product-webapi`的启动类引用此配置类：

```java
package cn.org.sqx.mall.product.webapi;

@SpringBootApplication
@Import({mallCommonConfiguration.class}) // 新增
public class mallProductWebapiApplication {

    public static void main(String[] args) {
        SpringApplication.run(mallProductWebapiApplication.class, args);
    }

}
```

接下来，即可执行测试：

```java
@Test
@Sql({"classpath:truncate.sql", "classpath:insert_data.sql"})
public void testAddNewFailBecauseNameDuplicate() throws Exception {
    // 准备测试数据，不需要封装，应该全部声明为String类型
    String name = "类别001";
    String parentId = "0"; // 即使目标类型是Long，参数值也不要加L
    String keywords = "水果的关键字是啥";
    String sort = "66";
    String icon = "图标待定";
    String isDisplay = "1";
    // 请求路径，不需要写协议、服务器主机和端口号
    String url = "/categories/add-new";
    // 执行测试
    // 以下代码相对比较固定
    mockMvc.perform( // 执行发出请求
            MockMvcRequestBuilders.post(url) // 根据请求方式决定调用的方法
                    .contentType(MediaType.APPLICATION_FORM_URLENCODED) // 请求数据的文档类型，例如：application/json; charset=utf-8
                    .param("name", name) // 请求参数，有多个时，多次调用param()方法
                    .param("parentId", parentId)
                    .param("keywords", keywords)
                    .param("icon", icon)
                    .param("sort", sort)
                    .param("isDisplay", isDisplay)
                    .accept(MediaType.APPLICATION_JSON)) // 接收的响应结果的文档类型，注意：perform()方法到此结束
            .andExpect( // 预判结果，类似断言
                    MockMvcResultMatchers
                            .jsonPath("state") // 预判响应的JSON结果中将有名为state的属性
                            .value(State.ERR_CATEGORY_NAME_DUPLICATE.getValue())) // 预判响应的JSON结果中名为state的属性的值，注意：andExpect()方法到此结束
            .andDo( // 需要执行某任务
                    MockMvcResultHandlers.print()); // 打印日志
}

@Test
@Sql({"classpath:truncate.sql"})
public void testAddNewFailBecauseParentNotFound() throws Exception {
    // 准备测试数据，不需要封装，应该全部声明为String类型
    String name = "类别001";
    String parentId = "-1"; // 即使目标类型是Long，参数值也不要加L
    String keywords = "水果的关键字是啥";
    String sort = "66";
    String icon = "图标待定";
    String isDisplay = "1";
    // 请求路径，不需要写协议、服务器主机和端口号
    String url = "/categories/add-new";
    // 执行测试
    // 以下代码相对比较固定
    mockMvc.perform( // 执行发出请求
            MockMvcRequestBuilders.post(url) // 根据请求方式决定调用的方法
                    .contentType(MediaType.APPLICATION_FORM_URLENCODED) // 请求数据的文档类型，例如：application/json; charset=utf-8
                    .param("name", name) // 请求参数，有多个时，多次调用param()方法
                    .param("parentId", parentId)
                    .param("keywords", keywords)
                    .param("icon", icon)
                    .param("sort", sort)
                    .param("isDisplay", isDisplay)
                    .accept(MediaType.APPLICATION_JSON)) // 接收的响应结果的文档类型，注意：perform()方法到此结束
            .andExpect( // 预判结果，类似断言
                    MockMvcResultMatchers
                            .jsonPath("state") // 预判响应的JSON结果中将有名为state的属性
                            .value(State.ERR_CATEGORY_NOT_FOUND.getValue())) // 预判响应的JSON结果中名为state的属性的值，注意：andExpect()方法到此结束
            .andDo( // 需要执行某任务
                    MockMvcResultHandlers.print()); // 打印日志
}
```

## 12.5. 验证请求参数格式的基本有效性

关于Validation框架的基本使用：

- 添加依赖
- 在控制器类中处理请求的方法的被验证的参数（封装的对象）之前添加`@Validated` / `@Valid`
- 在参数的类型（封装的类型）的属性之前添加验证注解
- 在统一处理异常的类中对`BindException`进行处理

先在`mall-product-webapi`中添加依赖（如果已经添加，则不需要重复添加）：

```xml
<!-- Spring Boot Validation：验证请求参数的基本格式 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

在`CategoryController`处理请求的方法的参数之前添加`@Validated` / `@Valid`注解：

```java
@PostMapping("/add-new")
// ===== 在以下方法的参数前添加@Validated / @Valid注解 =====
public JsonResult<Void> addNew(@Validated CategoryAddNewDTO categoryAddNewDTO) {
    categoryService.addNew(categoryAddNewDTO);
    return JsonResult.ok();
}
```

由于`CategoryAddNewDTO`等类在`mall-pojo`模块中的，要在此类中添加`@NotNull`等注解，则必须在`mall-pojo`中添加依赖：

```xml
<!-- Spring Boot Validation：验证请求参数的基本格式 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
    <scope>provided</scope>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </exclusion>
        <exclusion>
            <groupId>org.apache.tomcat.embed</groupId>
            <artifactId>tomcat-embed-el</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

然后，`CategoryAddNewDTO`的`name`属性上添加`@NotNull`约束（其它的约束等到测试通过之后再补充）：

```java
@Data
public class CategoryAddNewDTO implements Serializable {

    @NotNull(message = "添加类别失败，必须填写类别名称！") // 新增
    private String name;
    
    // ===== 其它原有代码 =====
    
}
```

在`State`中添加对应“请求参数格式错误”的枚举值：

```java
public enum State {

    OK(20000),
    // ===== 下行为新增 ======
    ERR_BAD_REQUEST(40000), // 客户端引起的--请求参数格式错误
    
    // ===== 其它原有代码 =====
}
```

在`GlobalExceptionHandler`中添加新的处理异常的方法：

```java
@ExceptionHandler(BindException.class)
public JsonResult<Void> handleBindException(BindException ex) {
    List<FieldError> fieldErrors = ex.getBindingResult().getFieldErrors();
    StringBuilder stringBuilder = new StringBuilder();
    for (FieldError fieldError : fieldErrors) {
        stringBuilder.append("；");
        stringBuilder.append(fieldError.getDefaultMessage());
    }
    String message = stringBuilder.substring(1);
    return JsonResult.fail(State.ERR_BAD_REQUEST, message);
}
```

最后，添加测试：

```java
@Test
@Sql({"classpath:truncate.sql"})
public void testAddNewFailBecauseBadRequest() throws Exception {
    // 准备测试数据，注意：此次没有提交必要的name属性值
    String parentId = "0"; // 即使目标类型是Long，参数值也不要加L
    String keywords = "水果的关键字是啥";
    String sort = "66";
    String icon = "图标待定";
    String isDisplay = "1";
    // 请求路径，不需要写协议、服务器主机和端口号
    String url = "/categories/add-new";
    // 执行测试
    // 以下代码相对比较固定
    mockMvc.perform( // 执行发出请求
            MockMvcRequestBuilders.post(url) // 根据请求方式决定调用的方法
                    .contentType(MediaType.APPLICATION_FORM_URLENCODED) // 请求数据的文档类型，例如：application/json; charset=utf-8
                    // .param("name", name) // 注意：此处不提交必要的name属性
                    .param("parentId", parentId)
                    .param("keywords", keywords)
                    .param("icon", icon)
                    .param("sort", sort)
                    .param("isDisplay", isDisplay)
                    .accept(MediaType.APPLICATION_JSON)) // 接收的响应结果的文档类型，注意：perform()方法到此结束
            .andExpect( // 预判结果，类似断言
                    MockMvcResultMatchers
                            .jsonPath("state") // 预判响应的JSON结果中将有名为state的属性
                            .value(State.ERR_BAD_REQUEST.getValue())) // 预判响应的JSON结果中名为state的属性的值，注意：andExpect()方法到此结束
            .andDo( // 需要执行某任务
                    MockMvcResultHandlers.print()); // 打印日志
}
```

测试成功后，应该在`CategoryAddNewDTO`的各属性中补充更多的、必要的注解进行约束，并且，添加更多约束后，还应该编写更多的测试。

# 13. 类别管理--根据父级类别查询其所有子级类别--持久层

## 13.1. 规划SQL语句

本次需要执行的SQL语句大致是：

```mysql
select * from pms_category where parent_id=? and enable=1 and is_display=1 order by sort desc, gmt_modified desc;
```

关于字段列表，应该包括：

```java
id, name, sort, icon, is_parent
```

## 13.2. 抽象方法（可能需要创建VO类）

在`mall-pojo`的根包下的`vo`包下创建`CategorySimpleListItemVO`类，封装以上设计的5个字段对应的属性：

```java
package cn.org.sqx.mall.pojo.vo;

import lombok.Data;

import java.io.Serializable;

@Data
public class CategorySimpleListItemVO implements Serializable {

    private Long id;
    private String name;
    private Integer sort;
    private String icon;
    private Integer isParent;

}
```

在`CategoryMapper`接口中添加：

```java
List<CategorySimpleListItemVO> listByParentId(Long parentId);
```

## 13.3. 在XML中配置SQL

在`CategoryMapper.xml`中添加配置：

```xml
<!-- List<CategorySimpleListItemVO> listByParentId(Long parentId); -->
<select id="listByParentId" resultMap="SimpleListResultMap">
    select
        <include refid="SimpleListQueryFields" />
    from
        pms_category
    where
        parent_id=#{id} and enable=1 and is_display=1
    order by
        sort desc, gmt_modified desc
</select>

<sql id="SimpleListQueryFields">
    <if test="true">
        id, name, sort, icon, is_parent
    </if>
</sql>

<resultMap id="SimpleListResultMap" type="cn.org.sqx.mall.pojo.vo.CategorySimpleListItemVO">
    <id column="id" property="id" />
    <result column="name" property="name" />
    <result column="sort" property="sort" />
    <result column="icon" property="icon" />
    <result column="is_parent" property="isParent" />
</resultMap>
```

## 13.4. 测试

本次测试推荐使用人工检查查询结果。

```java
@Test
@Sql({"classpath:truncate.sql", "classpath:insert_data.sql"})
public void testListByParentId() {
    // 测试数据
    Long parentId = 1L;
    // 执行测试，获取查询结果
    List<CategorySimpleListItemVO> list = mapper.listByParentId(parentId);
    // 查看结果
    System.out.println("查询结果数量：" + list.size());
    for (CategorySimpleListItemVO item : list) {
        System.out.println(item);
    }
}
```

# 14. 类别管理--根据父级类别查询其所有子级类别--业务逻辑层

## 14.1. 接口和抽象方法

在`ICategoryService`中添加：

```java
List<CategorySimpleListItemVO> listByParentId(Long parentId);
```

## 14.2. 实现

在`CategoryServiceImpl`中直接调用`categoryMapper`执行查询并返回即可。

```java
@Override
public List<CategorySimpleListItemVO> listByParentId(Long parentId) {
    return categoryMapper.listByParentId(parentId);
}
```

## 14.3. 测试

与持久层测试类似。

```java
@Test
@Sql({"classpath:truncate.sql", "classpath:insert_data.sql"})
public void testListByParentId() {
    // 测试数据
    Long parentId = 1L;
    // 执行测试，获取查询结果
    List<CategorySimpleListItemVO> list = service.listByParentId(parentId);
    // 查看结果
    System.out.println("查询结果数量：" + list.size());
    for (CategorySimpleListItemVO item : list) {
        System.out.println(item);
    }
}
```

# 15. 类别管理--根据父级类别查询其所有子级类别--控制器层

在`CategoryController`中添加：

```java
@GetMapping("/list-by-parent")
public JsonResult<List<CategorySimpleListItemVO>> listByParentId(Long parentId) {
    // 调用service并将结果封装到JsonResult中
    List<CategorySimpleListItemVO> list = categoryService.listByParentId(parentId);
    return JsonResult.ok(list);
}
```

在`CategoryControllerTests`中测试：

```java
@Test
@Sql({"classpath:truncate.sql", "classpath:insert_data.sql"})
public void testListByParentId() throws Exception {
    // 准备测试数据，注意：此次没有提交必要的name属性值
    String parentId = "0";
    // 请求路径，不需要写协议、服务器主机和端口号
    String url = "/categories/list-by-parent";
    // 执行测试
    // 以下代码相对比较固定
    mockMvc.perform( // 执行发出请求
            MockMvcRequestBuilders.get(url) // 根据请求方式决定调用的方法
                    .contentType(MediaType.APPLICATION_FORM_URLENCODED) // 请求数据的文档类型，例如：application/json; charset=utf-8
                    .param("parentId", parentId)
                    .accept(MediaType.APPLICATION_JSON)) // 接收的响应结果的文档类型，注意：perform()方法到此结束
            .andExpect( // 预判结果，类似断言
                    MockMvcResultMatchers
                            .jsonPath("state") // 预判响应的JSON结果中将有名为state的属性
                            .value(State.OK.getValue())) // 预判响应的JSON结果中名为state的属性的值，注意：andExpect()方法到此结束
            .andDo( // 需要执行某任务
                    MockMvcResultHandlers.print()); // 打印日志
}
```

# 16. 类别管理--根据id查询类别详情--持久层

## 16.1. 规划SQL语句

本次需要执行的SQL语句大致是：

```mysql
select * from pms_category where id=?
```

关于字段列表，应该包括：

```java
id, name, parent_id, depth, keywords, sort, icon, enable, is_parent, is_display
```

## 16.2. 抽象方法（可能需要创建VO类）

在`mall-pojo`的根包下的`vo`包下创建`CategoryDetailsVO`类，封装以上设计的字段对应的属性：

```java
package cn.org.sqx.mall.pojo.vo;

import lombok.Data;

import java.io.Serializable;

@Data
public class CategoryDetailsVO implements Serializable {

    private Long id;
    private String name;
    private Long parentId;
    private Integer depth;
    private String keywords;
    private Integer sort;
    private String icon;
    private Integer enable;
    private Integer isParent;
    private Integer isDisplay;

}
```

在`CategoryMapper`接口中添加：

```java
CategoryDetailsVO getDetailsById(Long id);
```

## 16.3. 在XML中配置SQL

在`CategoryMapper.xml`中添加配置：

```xml
<!-- CategoryDetailsVO getDetailsById(Long id); -->
<select id="getDetailsById" resultMap="DetailsResultMap">
    select
        <include refid="DetailsQueryFields"/>
    from
        pms_category
    where
        id=#{id}
</select>

<sql id="DetailsQueryFields">
    <if test="true">
        id, name, parent_id, depth, keywords,
        sort, icon, enable, is_parent, is_display
    </if>
</sql>

<resultMap id="DetailsResultMap" type="cn.org.sqx.mall.pojo.vo.CategoryDetailsVO">
    <id column="id" property="id" />
    <result column="name" property="name" />
    <result column="parent_id" property="parentId" />
    <result column="depth" property="depth" />
    <result column="keywords" property="keywords" />
    <result column="sort" property="sort" />
    <result column="icon" property="icon" />
    <result column="enable" property="enable" />
    <result column="is_parent" property="isParent" />
    <result column="is_display" property="isDisplay" />
</resultMap>
```

## 16.4. 测试

```java
@Test
@Sql({"classpath:truncate.sql", "classpath:insert_data.sql"})
public void testGetDetailsByIdSuccessfully() {
    // 测试数据
    Long id = 1L;
    // 断言不会抛出异常
    assertDoesNotThrow(() -> {
        // 执行查询
        Object category = mapper.getDetailsById(id);
        // 断言查询结果不为null
        assertNotNull(category);
    });
}

@Test
@Sql({"classpath:truncate.sql"})
public void testGetDetailsByIdFailBecauseNotFound() {
    // 测试数据
    Long id = -1L;
    // 断言不会抛出异常
    assertDoesNotThrow(() -> {
        // 执行查询
        Object category = mapper.getDetailsById(id);
        // 断言查询结果为null
        assertNull(category);
    });
}
```

# 17. 类别管理--根据id查询类别详情--业务逻辑层

## 14.1. 接口和抽象方法

在`ICategoryService`中添加：

```java
CategoryDetailsVO getDetailsById(Long id);
```

## 17.2. 实现

在`CategoryServiceImpl`中执行查询并返回。

```java
@Override
    public CategoryDetailsVO getDetailsById(Long id) {
        CategoryDetailsVO category = categoryMapper.getDetailsById(id);
        if (category == null) {
            throw new ServiceException(State.ERR_CATEGORY_NOT_FOUND, "获取类别详情失败，尝试访问的数据不存在！");
        }
        return category;
    }
```

## 17.3. 测试

```java
@Test
@Sql({"classpath:truncate.sql", "classpath:insert_data.sql"})
public void testGetDetailsByIdSuccessfully() {
    // 测试数据
    Long id = 1L;
    // 断言不抛出异常
    assertDoesNotThrow(() -> {
        service.getDetailsById(id);
    });
}

@Test
@Sql({"classpath:truncate.sql"})
public void testGetDetailsByIdFailBecauseNotFound() {
    // 测试数据
    Long id = -1L;
    // 断言抛出异常
    assertThrows(ServiceException.class, () -> {
        service.getDetailsById(id);
    });
}
```

# 18. 类别管理--根据id查询类别详情--控制器层

在`CategoryController`中添加：

```java
@GetMapping("/{id}")
public JsonResult<CategoryDetailsVO> getDetailsById(@PathVariable Long id) {
    CategoryDetailsVO category = categoryService.getDetailsById(id);
    return JsonResult.ok(category);
}
```

在`CategoryControllerTests`中测试：

```java
@Test
@Sql({"classpath:truncate.sql", "classpath:insert_data.sql"})
public void testGetDetailsByIdSuccessfully() throws Exception {
    // 准备测试数据，注意：此次没有提交必要的name属性值
    String id = "1";
    // 请求路径，不需要写协议、服务器主机和端口号
    String url = "/categories/" + id;
    // 执行测试
    // 以下代码相对比较固定
    mockMvc.perform( // 执行发出请求
            MockMvcRequestBuilders.get(url) // 根据请求方式决定调用的方法
                    .contentType(MediaType.APPLICATION_FORM_URLENCODED) // 请求数据的文档类型，例如：application/json; charset=utf-8
                    .accept(MediaType.APPLICATION_JSON)) // 接收的响应结果的文档类型，注意：perform()方法到此结束
            .andExpect( // 预判结果，类似断言
                    MockMvcResultMatchers
                            .jsonPath("state") // 预判响应的JSON结果中将有名为state的属性
                            .value(State.OK.getValue())) // 预判响应的JSON结果中名为state的属性的值，注意：andExpect()方法到此结束
            .andDo( // 需要执行某任务
                    MockMvcResultHandlers.print()); // 打印日志
}

@Test
@Sql({"classpath:truncate.sql", "classpath:insert_data.sql"})
public void testGetDetailsByIdFailBecauseNotFound() throws Exception {
    // 准备测试数据，注意：此次没有提交必要的name属性值
    String id = "9999999999";
    // 请求路径，不需要写协议、服务器主机和端口号
    String url = "/categories/" + id;
    // 执行测试
    // 以下代码相对比较固定
    mockMvc.perform( // 执行发出请求
            MockMvcRequestBuilders.get(url) // 根据请求方式决定调用的方法
                    .contentType(MediaType.APPLICATION_FORM_URLENCODED) // 请求数据的文档类型，例如：application/json; charset=utf-8
                    .accept(MediaType.APPLICATION_JSON)) // 接收的响应结果的文档类型，注意：perform()方法到此结束
            .andExpect( // 预判结果，类似断言
                    MockMvcResultMatchers
                            .jsonPath("state") // 预判响应的JSON结果中将有名为state的属性
                            .value(State.ERR_CATEGORY_NOT_FOUND.getValue())) // 预判响应的JSON结果中名为state的属性的值，注意：andExpect()方法到此结束
            .andDo( // 需要执行某任务
                    MockMvcResultHandlers.print()); // 打印日志
}
```

# 19. 使用Redis

Redis是一款基于内存的NoSQL数据存储服务，是非关系型的，是使用K-V结构进行存储的

- 基于内存：读写数据均在内存中直接操作
- NoSQL：通常把能够存、取数据的服务都称之为数据库，所以，Redis也是数据库，但是，它没有SQL语句

在基于Spring Boot的开发中，当需要在程序中访问Redis中的数据时，需要添加`spring-boot-starter-data-redis`依赖项。

要操作Redis中的数据，需要使用`RedisTemplate`对象，则在`mall-product-webapi`的根包下的`config`包中创建`RedisConfiguration`类，并在其中进行配置：

```java
@Configuration
public class RedisConfiguration {
    
    @Bean
    public RedisTemplate<String, Serializable> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<String, Serializable> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        redisTemplate.setKeySerializer(RedisSerializer.string());
        redisTemplate.setValueSerializer(RedisSerializer.json());
        return redisTemplate;
    }
    
}
```

接下来，在测试的根包下创建`RedisTests`来测试访问Redis中的数据：

```java
@SpringBootTest
public class RedisTests {

    @Autowired
    RedisTemplate<String, Serializable> redisTemplate;

    @Test
    void testSetValue() {
        redisTemplate.opsForValue()
                .set("name", "liuguobin");
    }

    @Test
    void testSetValueTTL() {
        redisTemplate.opsForValue()
                .set("name", "fanchuanqi", 60, TimeUnit.SECONDS);
    }

    @Test
    void testSetObjectValue() {
        CategoryDetailsVO category = new CategoryDetailsVO();
        category.setId(65L);
        category.setIsParent(1);
        category.setDepth(1);
        category.setName("水果");
        redisTemplate.opsForValue()
                .set("category", category);
    }

    @Test
    void testGetValue() {
        // 当key存在时，可获取到有效值
        // 当key不存在时，获取到的结果将是null
        Serializable name = redisTemplate.opsForValue()
                .get("name");
        System.out.println("get value --> " + name);
    }

    @Test
    void testGetObjectValue() {
        // 当key存在时，可获取到有效值
        // 当key不存在时，获取到的结果将是null
        Serializable serializable = redisTemplate.opsForValue()
                .get("category");
        System.out.println("get value --> " + serializable);
        if (serializable != null) {
            CategoryDetailsVO category = (CategoryDetailsVO) serializable;
            System.out.println("get value --> " + category);
        }
    }

    @Test
    void testDeleteKey() {
        // 删除key时，将返回“是否成功删除”
        // 当key存在时，将返回true
        // 当key不存在时，将返回false
        Boolean result = redisTemplate.delete("name");
        System.out.println("result --> " + result);
    }

    @Test
    void testRightPushList() {
        // 存入List时，需要redisTemplate.opsForList()得到针对List的操作器
        // 通过rightPush()可以向Redis中的List追加数据
        // 每次调用rightPush()时使用的key必须是同一个，才能把多个数据放到同一个List中
        List<CategoryDetailsVO> list = new ArrayList<>();
        for (int i = 1; i <= 5; i++) {
            CategoryDetailsVO category = new CategoryDetailsVO();
            category.setName("类别00" + i);
            list.add(category);
        }

        String key = "categoryList";
        for (CategoryDetailsVO category : list) {
            redisTemplate.opsForList().rightPush(key, category);
        }
    }

    @Test
    void testListSize() {
        // 获取List的长度，即List中的元素数量
        String key = "categoryList";
        Long size = redisTemplate.opsForList().size(key);
        System.out.println("size --> " + size);
    }

    @Test
    void testRange() {
        // 调用opsForList()后再调用range(String key, long start, long end)方法取出List中的若干个数据，将得到List
        // long start：起始下标（结果中将包含）
        // long end：结束下标（结果中将包含），如果需要取至最后一个元素，可使用-1作为此参数值
        String key = "categoryList";
        List<Serializable> range = redisTemplate.opsForList().range(key, 0, -1);
        for (Serializable serializable : range) {
            System.out.println(serializable);
        }
    }

    @Test
    void testKeys() {
        // 调用keys()方法可以找出匹配模式的所有key
        // 在模式中，可以使用星号作为通配符
        Set<String> keys = redisTemplate.keys("*");
        for (String key : keys) {
            System.out.println(key);
        }
    }

}
```

最后，关于Key的使用，通常建议使用冒号区分多层次，类似URL的设计方式，例如：

- 类别列表的Key：`categories:list`或`categories`
- 某个id（9527）对应的类别的Key：`categories:item:9527`

# 20.使用Redis缓存数据

使用Redis可以提高查询效率，一定程度上可以减轻数据库服务器的压力，从而保护了数据库。

通常，应用Redis的场景有：

- 高频查询，例如：热搜列表、秒杀
- 改变频率低的数据，例如：商品类别

一旦使用Redis，就会导致Redis和数据库中都存在同样的数据，当数据发生变化时，可能出现不一致的问题！

所以，还有某些数据在特定的场景中不能使用Redis：

- 要求数据必须是准确的：下单购买时要求库存是准确的
  - 如果每次库存发生变化时都更新了Redis中的库存值，保证了Redis中的数据是准确的，也可以使用
- 数据的修改频率很高，且对数据准确性有一定要求

需要学会评估是否要求数据一定保持一致！

要使用Redis缓存数据，至少需要：

- 开发新的组件，实现对Redis中的数据访问
  - 此组件并不是必须的，因为访问Redis数据的API都非常简单，自定义组件时，组件中的每个方法可能也只有少量代码，甚至只有1行代码
  - 如果直接将访问Redis的代码写在Service中，首次开发时会更省事，但不利于维护
  - 【推荐】如果将访问Redis的代码写的新的组件中，首次开发时会更麻烦，但利于维护
- 在Service中调用新的组件，在Service中决定何时访问MySQL，何时访问Redis

在使用Redis之前，还必须明确一些问题：

- 哪些查询功能改为从Redis中获取数据
- Redis中的数据从哪里来

暂定目标：

- 根据类别的id查询类别详情，改为从Redis中获取数据
- 优先从Redis中获取数据，如果Redis中没有，则从MySQL中获取，且获取到数据后，将数据存入到Redis中，所以，经过首次查询后，Redis中将存在此数据，后续每一次都可以直接从Redis中拿到必要的数据

在`cn.org.sqx.mall.product.webapi.repository`创建`ICategoryRedisRepository`接口，并在接口中添加抽象方法：

```java
public interface ICategoryRedisRepository {

    String KEY_CATEGORY_ITEM_PREFIX = "categories:item:";
    
    // 将类别详情存入到Redis中
    void save(CategoryDetailsVO category);
    
    // 根据类别id获取类别详情
    CategoryDetailsVO getDetailsById(Long id);
    
}
```

然后在`cn.org.sqx.mall.product.webapi.repository.impl`创建`CategoryRedisRepositoryImpl`（接口的实现类），实现以上接口：

```java
@Repository
public class CategoryRedisRepositoryImpl implements ICategoryRedisRepository {
    
    @Autowired
    private RedisTemplate<String, Serializable> redisTemplate;
    
    @Override
    public void save(CategoryDetailsVO category) {
        String key = KEY_CATEGORY_ITEM_PREFIX + category.getId();
        redisTemplate.opsForValue().set(key, category);
    }
    
    @Override
    public CategoryDetailsVO getDetailsById(Long id) {
        String key = KEY_CATEGORY_ITEM_PREFIX + id;
        Serializable result = redisTemplate.opsForValue().get(key);
        if (result == null) {
            return null;
        } else {
            CategoryDetailsVO category = (CategoryDetailsVO) result;
            return category;
        }
    }
}
```

完成后，测试：

```java
package cn.org.sqx.mall.product.webapi.repository;

import cn.org.sqx.mall.pojo.vo.CategoryDetailsVO;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
public class CategoryRedisRepositoryTests {

    @Autowired
    ICategoryRedisRepository repository;

    @Test
    void testGetDetailsByIdSuccessfully() {
        testSave();

        Long id = 10L;
        CategoryDetailsVO category = repository.getDetailsById(id);
        Assertions.assertNotNull(category);
    }

    @Test
    void testGetDetailsByIdReturnNull() {
        Long id = -1L;
        CategoryDetailsVO category = repository.getDetailsById(id);
        Assertions.assertNull(category);
    }

    private void testSave() {
        CategoryDetailsVO category = new CategoryDetailsVO();
        category.setId(10L);
        category.setName("家用电器");

        Assertions.assertDoesNotThrow(() -> {
            repository.save(category);
        });
    }
}
```

然后，需要修改`CategoryServiceImpl`中的实现：

```java
@Autowired
private ICategoryRedisRepository categoryRedisRepository;

@Override
public CategoryDetailsVO getDetailsById(Long id) {
    // ===== 以下是原有代码，只从数据库中获取数据 =====
    // CategoryDetailsVO category = categoryMapper.getDetailsById(id);
    // if (category == null) {
    //     throw new ServiceException(State.ERR_CATEGORY_NOT_FOUND,
    //             "获取类别详情失败，尝试访问的数据不存在！");
    // }
    // return category;
    
    // ===== 以下是新的业务，将从Redis中获取数据 =====
    // 从repsotiroy中调用方法，根据id获取缓存的数据
    // 判断缓存中是否存在与此id对应的key
    // 有：表示明确的存入过某数据，此数据可能是有效数据，也可能是null
    // -- 判断此key对应的数据是否为null
    // -- 是：表示明确的存入了null值，则此id对应的数据确实不存在，则抛出异常
    // -- 否：表示明确的存入了有效数据，则返回此数据即可
    
    // 无：表示从未向缓存中写入此id对应的数据，在数据库中，此id可能存在数据，也可能不存在
    // 从mapper中调用方法，根据id获取数据库的数据
    // 判断从数据库中获取的结果是否为null
    // 是：数据库也没有此数据，先向缓存中写入错误数据（null），再抛出异常
    
    // 将从数据库中查询到的结果存入到缓存中
    // 返回查询结果
}
```

为了避免缓存穿透，需要在`ICategoryRedisRepository`中添加2个抽象方法：

```java
/**
 * 判断是否存在id对应的缓存数据
 *
 * @param id 类别id
 * @return 存在则返回true，否则返回false
 */
boolean exists(Long id);

/**
 * 向缓存中写入某id对应的空数据（null），此方法主要用于解决缓存穿透问题
 *
 * @param id 类别id
 */
void saveEmptyValue(Long id);
```

并在`CategoryRedisRepositoryImpl`中补充实现：

```java
@Override
public boolean exists(Long id) {
    String key = KEY_CATEGORY_ITEM_PREFIX + id;
    return redisTemplate.hasKey(key);
}

@Override
public void saveEmptyValue(Long id) {
    String key = KEY_CATEGORY_ITEM_PREFIX + id;
    redisTemplate.opsForValue().set(key, null);
}
```

业务中的具体实现为：

```java
@Override
public CategoryDetailsVO getDetailsById(Long id) {
    // ===== 以下是原有代码，只从数据库中获取数据 =====
    // CategoryDetailsVO category = categoryMapper.getDetailsById(id);
    // if (category == null) {
    //     throw new ServiceException(State.ERR_CATEGORY_NOT_FOUND,
    //             "获取类别详情失败，尝试访问的数据不存在！");
    // }
    // return category;

    // ===== 以下是新的业务，将从Redis中获取数据 =====
    log.debug("根据id（{}）获取类别详情……", id);
    // 从repository中调用方法，根据id获取缓存的数据
    // 判断缓存中是否存在与此id对应的key
    boolean exists = categoryRedisRepository.exists(id);
    if (exists) {
        // 有：表示明确的存入过某数据，此数据可能是有效数据，也可能是null
        // -- 判断此key对应的数据是否为null
        CategoryDetailsVO cacheResult = categoryRedisRepository.getDetailsById(id);
        if (cacheResult == null) {
            // -- 是：表示明确的存入了null值，则此id对应的数据确实不存在，则抛出异常
            log.warn("在缓存中存在此id({})对应的Key，却是null值，则抛出异常", id);
            throw new ServiceException(State.ERR_CATEGORY_NOT_FOUND,
                    "获取类别详情失败，尝试访问的数据不存在！");
        } else {
            // -- 否：表示明确的存入了有效数据，则返回此数据即可
            return cacheResult;
        }
    }

    // 缓存中没有此id匹配的数据
    // 从mapper中调用方法，根据id获取数据库的数据
    log.debug("没有命中缓存，则从数据库查询数据……");
    CategoryDetailsVO dbResult = categoryMapper.getDetailsById(id);
    // 判断从数据库中获取的结果是否为null
    if (dbResult == null) {
        // 是：数据库也没有此数据，先向缓存中写入错误数据，再抛出异常
        log.warn("数据库中也无此数据（id={}），先向缓存中写入错误数据", id);
        categoryRedisRepository.saveEmptyValue(id);
        log.warn("抛出异常");
        throw new ServiceException(State.ERR_CATEGORY_NOT_FOUND,
                "获取类别详情失败，尝试访问的数据不存在！");
    }

    // 将从数据库中查询到的结果存入到缓存中
    log.debug("已经从数据库查询到匹配的数据，将数据存入缓存……");
    categoryRedisRepository.save(dbResult);
    // 返回查询结果
    log.debug("返回查询到数据：{}", dbResult);
    return dbResult;
}
```

许多缓存数据应该是服务器刚刚启动就直接写入到Redis中的，当后续客户端访问时，缓存中已经存在的数据可以直接响应，避免获取数据时缓存中还没有对应的数据，还需要从数据库中查询。

在服务器刚刚启动时就加载需要缓存的数据并写入到Redis中，这种做法称之为缓存预热。

需要解决的问题有：

- 需要实现开机启动时自动执行某个任务
- 哪些数据需要写入到缓存中，例如全部“类别”数据

在Spring Boot中，可以自定义某个组件类，实现`ApplicationRunner`即可，例如：

```java
package cn.org.sqx.mall.product.webapi.app;

import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

@Component
public class CachePreLoad implements ApplicationRunner {

    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("CachePreLoad.run()");
    }

}
```

为了将全部“类别”写入到缓存中，首先，需要能够从数据库中查询到全部数据，则需要：

- 在`CategoryMapper`接口中添加：`List<CategoryDetailsVO> list();`
- 在`CategoryMapper.xml`中配置以上抽象方法映射的SQL语句

然后，还需要实现将查询到的`List<CategoryDetailsVO>`写入到Redis中，则需要：

- 在`ICategoryRedisRepository`接口中添加：`void save(List<CategoryDetailsVO> categories);`
- 在`CategoryRedisRepositoryImpl`中实现以上方法
  - 存入时，Key值可以是：`categories:list`

由于向Redis中存入列表数据始终是“追加”的，且Redis中的数据并不会因为项目重启而消失，所以，如果反复启动项目，会在Redis的列表中反复追加重复的数据！为了避免此问题，应该在每次缓存预热之间先删除现有数据，所以，还需要：

- 在`ICategoryRedisRepository`接口中添加：`Boolean deleteList();`
- 在`CategoryRedisRepositoryImpl`中实现以上方法

从设计的角度，Service是可以调用数据访问层的组件的，即可以调用Mapper或其它Repository组件，换言之，Mapper和其它Repository组件**应该只被Service调用**！

所以，应该在`ICategoryService`中定义“预热类别数据的缓存”的抽象方法：

```java
void preloadCache();
```

另外，在Redis中存入了整个“类别”的列表后，也只能一次性拿到整个列表，不便于根据“类别”的id获取指定的数据，反之，如果每个“类别”数据都独立的存入到Redis中，当需要获取整个列表时，也只能把每个数据都找出来，然后再在Java程序中存入到`List`集合中，操作也是不方便的，所以，当需要更加关注效率时，应该将类别数据存2份到Redis中，一份是整个列表，另一份是若干个独立的类别数据。

目前，在缓存中存入独立的各个类别数据，在预热时并没有清除这些数据，如果在数据库中删除了数据，但缓存中的数据仍存在，为了避免这样的错误，应该在预热时，补充“删除所有类别”的功能！

则在`ICategoryRedisRepository`中添加`void deleteAllItem();`方法，用于删除所有独立的类别数据。

相关代码：`ICategoryRedisRepository`：

```java
package cn.org.sqx.mall.product.webapi.repository;

import cn.org.sqx.mall.pojo.vo.CategoryDetailsVO;

import java.util.List;

public interface ICategoryRedisRepository {

    /**
     * 类别数据的KEY的前缀
     */
    String KEY_CATEGORY_ITEM_PREFIX = "categories:item:";
    /**
     * 类别列表的KEY
     */
    String KEY_CATEGORY_LIST = "categories:list";

    /**
     * 判断是否存在id对应的缓存数据
     *
     * @param id 类别id
     * @return 存在则返回true，否则返回false
     */
    Boolean exists(Long id);

    /**
     * 向缓存中写入某id对应的空数据（null），此方法主要用于解决缓存穿透问题
     *
     * @param id 类别id
     */
    void saveEmptyValue(Long id);

    /**
     * 将类别详情存入到Redis中
     *
     * @param category 类别详情
     */
    void save(CategoryDetailsVO category);

    /**
     * 将类别的列表存入到Redis中
     *
     * @param categories 类别列表
     */
    void save(List<CategoryDetailsVO> categories);

    /**
     * 删除Redis中各独立存储的类别数据
     */
    void deleteAllItem();

    /**
     * 删除Redis中的类别列表
     * @return 如果成功删除，则返回true，否则返回false
     */
    Boolean deleteList();

    /**
     * 根据类别id获取类别详情
     *
     * @param id 类别id
     * @return 匹配的类别详情，如果没有匹配的数据，则返回null
     */
    CategoryDetailsVO getDetailsById(Long id);

}
```

相关代码：`CategoryRedisRepositoryImpl`：

```java
package cn.org.sqx.mall.product.webapi.repository.impl;

import cn.org.sqx.mall.pojo.vo.CategoryDetailsVO;
import cn.org.sqx.mall.product.webapi.repository.ICategoryRedisRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Repository;

import java.io.Serializable;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;

@Repository
public class CategoryRedisRepositoryImpl implements ICategoryRedisRepository {

    @Autowired
    private RedisTemplate<String, Serializable> redisTemplate;

    @Override
    public Boolean exists(Long id) {
        String key = KEY_CATEGORY_ITEM_PREFIX + id;
        return redisTemplate.hasKey(key);
    }

    @Override
    public void saveEmptyValue(Long id) {
        String key = KEY_CATEGORY_ITEM_PREFIX + id;
        redisTemplate.opsForValue().set(key, null, 30, TimeUnit.SECONDS);
    }

    @Override
    public void save(CategoryDetailsVO category) {
        String key = KEY_CATEGORY_ITEM_PREFIX + category.getId();
        redisTemplate.opsForValue().set(key, category);
    }

    @Override
    public void save(List<CategoryDetailsVO> categories) {
        for (CategoryDetailsVO category : categories) {
            redisTemplate.opsForList().rightPush(KEY_CATEGORY_LIST, category);
        }
    }

    @Override
    public void deleteAllItem() {
        Set<String> keys = redisTemplate.keys(KEY_CATEGORY_ITEM_PREFIX + "*");
        redisTemplate.delete(keys);
    }

    @Override
    public Boolean deleteList() {
        return redisTemplate.delete(KEY_CATEGORY_LIST);
    }

    @Override
    public CategoryDetailsVO getDetailsById(Long id) {
        String key = KEY_CATEGORY_ITEM_PREFIX + id;
        Serializable result = redisTemplate.opsForValue().get(key);
        if (result == null) {
            return null;
        } else {
            CategoryDetailsVO category = (CategoryDetailsVO) result;
            return category;
        }
    }
}
```

相关代码：缓存预热的业务代码（以下方法的声明在`ICategoryService`接口中，以下代码是`CategoryServiceImpl`中重写的方法）：

```java
@Override
public void preloadCache() {
    log.debug("删除缓存中的类别列表……");
    categoryRedisRepository.deleteList();
    log.debug("删除缓存中的各独立的类别数据……");
    categoryRedisRepository.deleteAllItem();

    log.debug("从数据库查询类别列表……");
    List<CategoryDetailsVO> list = categoryMapper.list();

    for (CategoryDetailsVO category : list) {
        log.debug("查询结果：{}", category);
        log.debug("将当前类别存入到Redis：{}", category);
        categoryRedisRepository.save(category);
    }

    log.debug("将类别列表写入到Redis……");
    categoryRedisRepository.save(list);
    log.debug("将类别列表写入到Redis完成！");
}
```

相关代码：缓存预热类（`CachePreLoad`）：

```java
package cn.org.sqx.mall.product.webapi.app;

import cn.org.sqx.mall.product.service.ICategoryService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

@Component
@Slf4j
public class CachePreLoad implements ApplicationRunner {

    @Autowired
    private ICategoryService categoryService;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("CachePreLoad.run()");
        log.debug("准备执行缓存预热……");

        categoryService.preloadCache();

        log.debug("缓存预热完成！");
    }

}
```

# 21.管理员相关数据表

管理员及权限的管理，涉及的数据表有：

```sql
-- 数据库：mall_ams

-- 权限表：创建数据表
drop table if exists ams_permission;
create table ams_permission (
    id bigint unsigned auto_increment,
    name varchar(50) default null comment '名称',
    value varchar(255) default null comment '值',
    description varchar(255) default null comment '描述',
    sort tinyint unsigned default 0 comment '自定义排序序号',
    gmt_create datetime default null comment '数据创建时间',
    gmt_modified datetime default null comment '数据最后修改时间',
    primary key (id)
) comment '权限表' charset utf8mb4;

-- 权限表：插入测试数据
insert into ams_permission (name, value, description) values
('商品-商品管理-读取', '/pms/product/read', '读取商品数据，含列表、详情、查询等'),
('商品-商品管理-编辑', '/pms/product/update', '修改商品数据'),
('商品-商品管理-删除', '/pms/product/delete', '删除商品数据'),
('后台管理-管理员-读取', '/ams/admin/read', '读取管理员数据，含列表、详情、查询等'),
('后台管理-管理员-编辑', '/ams/admin/update', '编辑管理员数据'),
('后台管理-管理员-删除', '/ams/admin/delete', '删除管理员数据');

-- 角色表：创建数据表
drop table if exists ams_role;
create table ams_role (
    id bigint unsigned auto_increment,
    name varchar(50) default null comment '名称',
    description varchar(255) default null comment '描述',
    sort tinyint unsigned default 0 comment '自定义排序序号',
    gmt_create datetime default null comment '数据创建时间',
    gmt_modified datetime default null comment '数据最后修改时间',
    primary key (id)
) comment '角色表' charset utf8mb4;

-- 角色表：插入测试数据
insert into ams_role (name) values
    ('超级管理员'), ('系统管理员'), ('商品管理员'), ('订单管理员');

-- 角色权限关联表：创建数据表
drop table if exists ams_role_permission;
create table ams_role_permission (
    id bigint unsigned auto_increment,
    role_id bigint unsigned default null comment '角色id',
    permission_id bigint unsigned default null comment '权限id',
    gmt_create datetime default null comment '数据创建时间',
    gmt_modified datetime default null comment '数据最后修改时间',
    primary key (id)
) comment '角色权限关联表' charset utf8mb4;

-- 角色权限关联表：插入测试数据
insert into ams_role_permission (role_id, permission_id) values
    (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6),
    (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6),
    (3, 1), (3, 2), (3, 3);

-- 管理员表：创建数据表
drop table if exists ams_admin;
create table ams_admin (
    id bigint unsigned auto_increment,
    username varchar(50) default null unique comment '用户名',
    password char(64) default null comment '密码（密文）',
    nickname varchar(50) default null comment '昵称',
    avatar varchar(255) default null comment '头像URL',
    phone varchar(50) default null unique comment '手机号码',
    email varchar(50) default null unique comment '电子邮箱',
    description varchar(255) default null comment '描述',
    is_enable tinyint unsigned default 0 comment '是否启用，1=启用，0=未启用',
    last_login_ip varchar(50) default null comment '最后登录IP地址（冗余）',
    login_count int unsigned default 0 comment '累计登录次数（冗余）',
    gmt_last_login datetime default null comment '最后登录时间（冗余）',
    gmt_create datetime default null comment '数据创建时间',
    gmt_modified datetime default null comment '数据最后修改时间',
    primary key (id)
) comment '管理员表' charset utf8mb4;

-- 管理员表：插入测试数据
insert into ams_admin (username, password, nickname, email, description, is_enable) values
    ('root', '1234', 'root', 'root@tedu.cn', '最高管理员', 1),
    ('super_admin', '1234', 'administrator', 'admin@tedu.cn', '超级管理员', 1),
    ('nobody', '1234', '无名', 'liucs@tedu.cn', null, 0);

-- 管理员角色关联表：创建数据表
drop table if exists ams_admin_role;
create table ams_admin_role (
    id bigint unsigned auto_increment,
    admin_id bigint unsigned default null comment '管理员id',
    role_id bigint unsigned default null comment '角色id',
    gmt_create datetime default null comment '数据创建时间',
    gmt_modified datetime default null comment '数据最后修改时间',
    primary key (id)
) comment '管理员角色关联表' charset utf8mb4;

-- 管理员角色关联表：插入测试数据
insert into ams_admin_role (admin_id, role_id) values
    (1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (2, 4), (3, 3);

-- 查询示例：查询id=1的管理员的权限
select distinct ams_permission.value from ams_permission
left join ams_role_permission on ams_role_permission.permission_id=ams_permission.id
left join ams_role on ams_role_permission.role_id=ams_role.id
left join ams_admin_role on ams_admin_role.role_id=ams_role.id
left join ams_admin on ams_admin_role.admin_id=ams_admin.id
where ams_admin.id=1
order by ams_permission.value;

-- 管理员登录日志表：创建数据表
drop table if exists ams_login_log;
create table ams_login_log (
    id bigint unsigned auto_increment,
    admin_id bigint unsigned default null comment '管理员id',
    username varchar(50) default null comment '管理员用户名（冗余）',
    nickname varchar(50) default null comment '管理员昵称（冗余）',
    ip varchar(50) default null comment '登录IP地址',
    user_agent varchar(255) default null comment '浏览器内核',
    gmt_login datetime default null comment '登录时间',
    gmt_create datetime default null comment '数据创建时间',
    gmt_modified datetime default null comment '数据最后修改时间',
    primary key (id)
) comment '管理员登录日志表' charset utf8mb4;

-- 管理员登录日志表：插入测试数据
insert into ams_login_log (admin_id, username, nickname, ip, user_agent, gmt_login) values
    (1, 'root', 'root', '127.0.0.1', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15', DATE_SUB(NOW(), interval 1 day)),
    (2, 'root', 'root', '127.0.0.1', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15', DATE_SUB(NOW(), interval 12 hour)),
    (3, 'root', 'root', '127.0.0.1', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15', NOW());

-- 查看数据表结构
desc ams_permission; desc ams_role; desc ams_role_permission; desc ams_admin; desc ams_admin_role; desc ams_login_log;
```

当某个管理员尝试登录时，必须实现”根据用户名查询此管理员的信息，至少包括id、密码、权限“，需要执行的SQL语句大致是：

```sql
-- 管理员表 admin
-- 角色表 role
-- 管理员与角色关联表 admin_role (admin_id, role_id)
-- 权限表 permission
-- 角色与权限关联表 role_permission (role_id, permission_id)
-- 【根据用户名查询管理员，且必须查出对应的权限】
select
    ams_admin.id,
    ams_admin.username,
    ams_admin.password,
    ams_admin.is_enable,
    ams_permission.value
from ams_admin
left join ams_admin_role on ams_admin.id = ams_admin_role.admin_id
left join ams_role_permission on ams_admin_role.role_id = ams_role_permission.role_id
left join ams_permission on ams_role_permission.permission_id = ams_permission.id
where username='root';
```

接下来，在根项目中创建`mall-admin`模块（与`mall-product`类似），并在其下创建`mall-admin-service`和`mall-admin-webapi`这2个子模块（与`mall-product`的2个子模块类似），然后，尽量在`mall-admin-webapi`中实现以上查询功能：

```java
public interface AdminMapper {
    AdminLoginVO findByUsername(String username);
}
```

# 22. 关于用户身份认证与授权

Spring Security是用于解决认证与授权的框架。

在根项目下创建新的`mall-passport`子模块，最基础的依赖项包括`spring-boot-starter-web`与`spring-boot-starter-security`（为避免默认存在的测试类出错，应该保留测试的依赖项`spring-boot-starter-test`），完整的`mall-passwort`的`pom.xml`为：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <!-- 父级项目 -->
    <parent>
        <groupId>cn.org.sqx</groupId>
        <artifactId>mall-server</artifactId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <!-- 当前项目的信息 -->
    <groupId>cn.org.sqx</groupId>
    <artifactId>mall-passport</artifactId>
    <version>1.0-SNAPSHOT</version>

    <!-- 当前项目需要使用的依赖项 -->
    <dependencies>
        <!-- Spring Boot Web：支持Spring MVC -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!-- Spring Boot Security：处理认证与授权 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <!-- Spring Boot Test：测试 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>
```

调整完成后，即可启动项目，在启动的日志中，可以看到类似以下内容：

```
Using generated security password: 2abb9119-b5bb-4de9-8584-9f893e4a5a92
```

Spring Security有默认登录的账号和密码（以上提示的值），密码是随机的，每次启动项目都会不同。

**Spring Security默认要求所有的请求都是必须先登录才允许的访问**，可以使用默认的用户名`user`和自动生成的随机密码来登录。在测试登录时，在浏览器访问当前主机的任意网址都可以（包括不存在的资源），会自动跳转到登录页（是由Spring Security提供的，默认的URL是：http://localhost:8080/login），当登录成功后，会自动跳转到此前访问的URL（跳转登录页之前的URL），另外，还可以通过 http://localhost:8080/logout 退出登录。

Spring Security的依赖项中包括了Bcrypt算法的工具类，Bcrypt是一款非常优秀的密码加密工具，适用于对需要存储下来的密码进行加密处理。

```java
package cn.org.sqx.mall.passport;

import org.junit.jupiter.api.Test;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

public class BcryptPasswordEncoderTests {

    private BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

    @Test
    public void testEncode() {
        // 原文相同的情况，每次加密得到的密文都不同
        for (int i = 0; i < 10; i++) {
            String rawPassword = "123456";
            String encodedPassword = passwordEncoder.encode(rawPassword);
            System.out.println("rawPassword = " + rawPassword);
            System.out.println("encodedPassword = " + encodedPassword);
        }
        // rawPassword = 123456
        // encodedPassword = $2a$10$HWuJ9WgPazrwg9.isaae4u7XdP7ohH7LetDwdlTWuPC4ZAvG.Uc7W
        // encodedPassword = $2a$10$rOwgZMpDvZ3Kn7CxHWiEbeC6bQMGtfX.VYc9DCzx9BxkWymX6FbrS
        // encodedPassword = $2a$10$H8ehVGsZx89lSVHwBVI37OkxWm8LXei4T1o5of82Hwc1rD0Yauhky
        // encodedPassword = $2a$10$meBbCiHZBcYn7zMrZ4fPd.hizrsiZhAu8tmDk.P8QJcCzSQGhXSvq
        // encodedPassword = $2a$10$bIRyvV29aoeJLo6hh1M.yOvKoOud5kC7AXDMSUW4tF/DlcG0bLj9C
        // encodedPassword = $2a$10$eq5BuoAiQ6Uo0.TOPZOFPuRNlPl3t2GoTlaFoYfBu3/Bo3tLzx.v2
        // encodedPassword = $2a$10$DhTSwQfNdqrGgHRmILmNLeV0jt3ZXL435xz0fwyZ315ciI5AuI5gi
        // encodedPassword = $2a$10$T.8/ISoLOdreEEkp4py36O0ZYfihDbdHDuIElZVF3uEgMOX.8sPcK
        // encodedPassword = $2a$10$hI4wweFOGJ7FMduSmcjNBexbKFOjYMWl8hkug0n0k1LNR5vEyhhMW
        // encodedPassword = $2a$10$b4ztMI6tWoiJuoDYKwr7DOywsPkkCdvDxbPfmEsLdp11NdABS7wyy
    }

    @Test
    public void testMatches() {
        String rawPassword = "123456";
        String encodedPassword = "$2a$10$hI4wweFOGJ7FMduSmCjNBexbKFOjYMWl8hkug0n0k1LNR5vEyhhMW";
        boolean matchResult = passwordEncoder.matches(rawPassword, encodedPassword);
        System.out.println("match result : " + matchResult);
    }

}
```

如果要使得Spring Security能使用数据库中的信息（数据库中的用户名与密码）来验证用户身份（认证），首先，必须实现“根据用户名查询此用户的登录信息（应该包括权限信息）”的查询功能，要实现此查询，需要执行的SQL语句大致是：

```mysql
select
    ams_admin.id,
    ams_admin.username,
    ams_admin.password,
    ams_admin.is_enable,
    ams_permission.value
from ams_admin
left join ams_admin_role on ams_admin.id = ams_admin_role.admin_id
left join ams_role_permission on ams_admin_role.role_id = ams_role_permission.role_id
left join ams_permission on ams_role_permission.permission_id = ams_permission.id
where username='root';
```

要在当前模块（`mall-passport`）中实现此查询功能，需要：

- [`mall-passport`] 添加数据库编程的相关依赖

  - `mysql-connector-java`
  - `mybatis-spring-boot-starter`
  - `durid` / `druid-spring-boot-starter`

- [`mall-passport`] 添加连接数据库的配置信息

- [`mall-passport`] 创建`MybatisConfiguration`配置类，用于配置`@MapperScan`

- [`mall-passport`] 在配置文件中配置`mybatis.mapper-locations`属性，以指定XML文件的位置

- [`mall-pojo`] 创建`AdminLoginVO`类

  ```java
  @Data
  public class AdminLoginVO implements Serializable {
      private Long id;
      private String username;
      private String password;
      private Integer isEnable;
      private List<String> permissions;
  }
  ```

- [`mall-passport`] 在`pom.xml`中添加对`mall-pojo`的依赖

- [`mall-passport`] 在`src/main/java`下的`cn.org.sqx.mall.passport`包下创建`mapper.AdminMapper.java`接口

- [`mall-passport`] 在接口中添加抽象方法：

  ```java
  AdminLoginVO getLoginInfoByUsername(String username);
  ```

- 在`src/main/resources`下创建`mapper`文件夹，并在此文件夹下粘贴得到`AdminMapper.xml`

- 在`AdminMapper.xml`中配置以上抽象方法映射的SQL查询：

  ```xml
  <!-- 忽略固定的代码 -->
  
  <mapper namespace="cn.org.sqx.mall.passport.mapper.AdminMapper">
      
      <!-- AdminLoginVO getLoginInfoByUsername(String username); -->
      <select id="getLoginInfoByUsername" resultMap="LoginInfoResultMap">
          select
              <include refid="LoginInfoQueryFields" />
          from ams_admin
          left join ams_admin_role 
          	on ams_admin.id = ams_admin_role.admin_id
          left join ams_role_permission 
          	on ams_admin_role.role_id = ams_role_permission.role_id
          left join ams_permission 
          	on ams_role_permission.permission_id = ams_permission.id
          where username=#{username}
      </select>
      
      <sql id="LoginInfoQueryFields">
          <if test="true">
          	ams_admin.id,
              ams_admin.username,
              ams_admin.password,
              ams_admin.is_enable,
              ams_permission.value
          </if>
      </sql>
      
      <resultMap id="LoginInfoResultMap" type="cn.org.sqx.mall.pojo.vo.AdminLoginVO">
          <id column="id" property="id" />
          <result column="username" property="username" />
          <result column="password" property="password" />
          <result column="is_enable" property="isEnable" />
          <collection property="permissions" ofType="java.lang.String">
              <!-- 以下配置类似在Java中执行 new String("/pms/product/read") -->
              <constructor>
              	<arg column="value" />
              </constructor>
          </collection>
      </resultMap>
      
  </mapper>
  ```

- 完成后，还应该编写并执行测试

根据有效的用户名查询出的结果例如：

```
AdminLoginVO(
	id=1, 
	username=root, 
	password=1234, 
	isEnable=1, 
	permissions=[
		/pms/product/read, 
		/pms/product/update, 
		/pms/product/delete, 
		/ams/admin/read, 
		/ams/admin/update, 
		/ams/admin/delete
	]
)
```

Spring Security的认证机制中包含：当客户端提交登录后，会自动调用`UserDetailsService`接口（Spring Security定义的）的实现类对象中的`UserDetails loadUserByUsername(String username)`方法（根据用户名加载用户数据），将得到`UserDetails`类型的对象，此对象中应该至少包括此用户名对应的密码、权限等信息，接下来，Spring Security会自动完成密码的对比，并确定此次客户端提交的信息是否允许登录！类似于：

```java
// Spring Security的行为
UserDetails userDetails = userDetailsService.loadUserByUsername("chengheng");
// Spring Security将从userDetails中获取密码，用于验证客户端提交的密码，判断是否匹配
```

所以，要实现Spring Security通过数据库的数据来验证用户名与密码（而不是采用默认的`user`用户名和随机的密码），则在`cn.org.sqx.mall.passport`包下创建`security.UserDetailsServiceImpl`类，实现`UserDetailsService`接口，并重写接口中的抽象方法：

```java
package cn.org.sqx.mall.passport.security;

import cn.org.sqx.mall.passport.mapper.AdminMapper;
import cn.org.sqx.mall.pojo.vo.AdminLoginVO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    @Autowired
    private AdminMapper adminMapper;

    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        System.out.println("根据用户名查询尝试登录的管理员信息，用户名=" + s);
        AdminLoginVO admin = adminMapper.getLoginInfoByUsername(s);
        System.out.println("通过持久层进行查询，结果=" + admin);

        if (admin == null) {
            System.out.println("根据用户名没有查询到有效的管理员数据，将抛出异常");
            throw new BadCredentialsException("登录失败，用户名不存在！");
        }

        System.out.println("查询到匹配的管理员数据，需要将此数据转换为UserDetails并返回");
        UserDetails userDetails = User.builder()
                .username(admin.getUsername())
                .password(admin.getPassword())
                .accountExpired(false)
                .accountLocked(false)
                .disabled(admin.getIsEnable() != 1)
                .credentialsExpired(false)
                .authorities(admin.getPermissions().toArray(new String[] {}))
                .build();
        System.out.println("转换得到UserDetails=" + userDetails);
        return userDetails;
    }

}
```

完成后，再配置密码加密器即可：

```java
package cn.org.sqx.mall.passport.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class SecurityConfiguration {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

}
```

重启项目，可以发现在启动过程中不再生成随机的密码值，在浏览器上访问此项目的任何URL，进入登录页，即可使用数据库中的管理员数据进行登录。

在Spring Security，默认使用Session机制存储成功登录的用户信息（因为HTTP协议是无状态协议，并不保存客户端的任何信息，所以，同一个客户端的多次访问，对于服务器而言，等效于多个不同的客户端各访问一次，为了保存用户信息，使得服务器端能够识别客户端的身份，必须采取某种机制），当下，更推荐使用Token或相关技术（例如JWT）来解决识别用户身份的问题。

**JWT** = **J**SON **W**eb **T**oken，它是通过JSON格式组织必要的数据，将数据记录在票据（Token）上，并且，结合一定的算法，使得这些数据会被加密，然后在网络上传输，服务器端收到此数据后，会先对此数据进行解密，从而得到票据上记录的数据（JSON数据），从而识别用户的身份，或者处理相关的数据。

其实，在客户端第1次访问服务器端时，是“空着手”访问的，不会携带任何票据数据，当服务器进行响应时，会将JWT响应到客户端，客户端从第2次访问开始，每次都应该携带JWT发起请求，则服务器都会收到请求中的JWT并进行处理。

要使用JWT，需要添加相关的依赖项，可以实现生成JWT、解析JWT的框架较多，目前，主流的JWT框架可以是`jjwt`：

```xml
<!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>
```

则在根项目中管理以上依赖，并在`mall-passport`中添加以上依赖。

测试使用JWT：

```java
package cn.org.sqx.mall.passport;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Header;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import org.junit.jupiter.api.Test;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

public class JwtTests {

    // 密钥
    String secretKey = "fgfdsfadsfadsafdsafdsfadsfadsfdsafdasfdsafdsafdsafds4rttrefds";

    @Test
    public void testGenerateJwt() {
        // Claims
        Map<String, Object> claims = new HashMap<>();
        claims.put("id", 9527);
        claims.put("name", "星星");

        // JWT的组成部分：Header（头），Payload（载荷），Signature（签名）
        String jwt = Jwts.builder()
                // Header：指定算法与当前数据类型
                // 格式为： { "alg": 算法, "typ": "jwt" }
                .setHeaderParam(Header.CONTENT_TYPE, "HS256")
                .setHeaderParam(Header.TYPE, Header.JWT_TYPE)
                // Payload：通常包含Claims（自定义数据）和过期时间
                .setClaims(claims)
                .setExpiration(new Date(System.currentTimeMillis() + 5 * 60 * 1000))
                // Signature：由算法和密钥（secret key）这2部分组成
                .signWith(SignatureAlgorithm.HS256, secretKey)
                // 打包生成
                .compact();

        // eyJjdHkiOiJIUzI1NiIsInR5cCI6IkpXVCIsImFsZyI6IkhTMjU2In0.eyJuYW1lIjoi5pif5pifIiwiaWQiOjk1MjcsImV4cCI6MTY1NTM2NTY3N30.QwBYVgdkdibEpD-pjX4sKfNu3tw8hBLcJy4-UcN1F3c
        // eyJjdHkiOiJIUzI1NiIsInR5cCI6IkpXVCIsImFsZyI6IkhTMjU2In0.eyJuYW1lIjoi5pif5pifIiwiaWQiOjk1MjcsImV4cCI6MTY1NTM2NzMwMn0.qBBHearv8iHPNjtDGtO2ci_-KAL4CALHnwzaG_ljsQg
        System.out.println(jwt);
    }

    @Test
    public void testParseJwt() {
        String jwt = "eyJjdHkiOiJIUzI1NiIsInR5cCI6IkpXVCIsImFsZyI6IkhTMjU2In0.eyJuYW1lIjoi5pif5pifIiwiaWQiOjk1MjcsImV4cCI6MTY1NTM2NzMwMn0.qBBHearv8iHPNjtDGtO2ci_-KAL4CALHnwzaG_ljsQg";
        Claims claims = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(jwt).getBody();
        Object id = claims.get("id");
        Object name = claims.get("name");
        System.out.println("id=" + id);
        System.out.println("name=" + name);
    }

}
```

当JWT数据过期时，异常信息例如：

```java
io.jsonwebtoken.ExpiredJwtException: JWT expired at 2022-06-16T15:47:57Z. Current time: 2022-06-16T16:08:32Z, a difference of 1235869 milliseconds.  Allowed clock skew: 0 milliseconds.
```

当JWT解析失败（数据有误）时，异常信息例如：

```java
io.jsonwebtoken.MalformedJwtException: Unable to read JSON value: {"cty"�"HS256","typ":"JWT","alg":"HS256"}
```

当生成JWT和解析JWT的密钥不一致时，异常信息例如：

```java
io.jsonwebtoken.SignatureException: JWT signature does not match locally computed signature. JWT validity cannot be asserted and should not be trusted.
```

要在Spring Security中使用JWT，至少需要：

- 不能让Spring Security按照原有模式来处理登录（原有模式中，登录成功后，自动装用户信息存储到Session中，且跳转页面），需要

  - 需要自动装配`AuthenticationManager`对象

    - 使得`SecurityConfiguration`配置类继承自`WebSecurityConfigurerAdapter`类，重写其中的`xx`方法，在此方法中直接调用父级方法即可，并在此方法上添加`@Bean`注解

  - 创建`AdminLoginDTO`类，此类中应该包含用户登录时需要提交的用户名、密码

  - 创建`IAdminService`接口

  - 在`IAdminService`接口中添加登录的抽象方法

    ```java
    String login(AdminLoginDTO adminLoginDTO);
    ```

  - 创建`AdminServiceImpl`类，实现以上接口

    - 在实现过程中，调用`AuthenticationManager`实现认证，当认证成功后，生成JWT并返回

  - 创建`AdminController`类，在类中处理登录请求

  - 在`SecurityConfiguration`中配置Spring Security，对特定的请求进行放行（默认所有请求都必须先登录）

相关代码：`SecurityConfiguration`：

```java
package cn.org.sqx.mall.passport.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // 禁用防跨域攻击
        http.csrf().disable();

        // URL白名单
        String[] urls = {
            "/admins/login"
        };

        // 配置各请求路径的认证与授权
        http.authorizeRequests() // 请求需要授权才可以访问
            .antMatchers(urls) // 匹配一些路径
            .permitAll() // 允许直接访问（不需要经过认证和授权）
            .anyRequest() // 匹配除了以上配置的其它请求
            .authenticated(); // 都需要认证
    }
}
```

相关代码：`AdminLoginDTO`：

```java
package cn.org.sqx.mall.pojo.dto;

import lombok.Data;

import java.io.Serializable;

@Data
public class AdminLoginDTO implements Serializable {

    private String username;
    private String password;

}
```

相关代码：`IAdminService`：

```java
package cn.org.sqx.mall.passport.service;

import cn.org.sqx.mall.pojo.dto.AdminLoginDTO;

public interface IAdminService {

    String login(AdminLoginDTO adminLoginDTO);

}
```

相关代码：`AdminServiceImpl`：

```java
package cn.org.sqx.mall.passport.service;

import cn.org.sqx.mall.pojo.dto.AdminLoginDTO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;

@Service
public class AdminServiceImpl implements IAdminService {

    @Autowired
    private AuthenticationManager authenticationManager;

    @Override
    public String login(AdminLoginDTO adminLoginDTO) {
        // 准备被认证数据
        Authentication authentication
                = new UsernamePasswordAuthenticationToken(
                        adminLoginDTO.getUsername(), adminLoginDTO.getPassword());
        // 调用AuthenticationManager验证用户名与密码
        // 执行认证，如果此过程没有抛出异常，则表示认证通过，如果认证信息有误，将抛出异常
        authenticationManager.authenticate(authentication);

        // 如果程序可以执行到此处，则表示登录成功
        // 生成此用户数据的JWT
        String jwt = "This is a JWT."; // 临时
        return jwt;
    }

}
```

相关代码：`AdminController`：

```java
package cn.org.sqx.mall.passport.controller;

import cn.org.sqx.mall.passport.service.IAdminService;
import cn.org.sqx.mall.pojo.dto.AdminLoginDTO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(value = "/admins", produces = "application/json; charset=utf-8")
public class AdminController {

    @Autowired
    private IAdminService adminService;

    // http://localhost:8080/admins/login?username=root&password=123456
    @RequestMapping("/login")
    public String login(AdminLoginDTO adminLoginDTO) {
        String jwt = adminService.login(adminLoginDTO);
        return jwt;
    }

}
```

以上全部完成后，启动项目，打开浏览器，可以通过 http://localhost:8080/admins/login?username=root&password=123456 这类URL测试登录，使用数据库中的用户名和密码进行尝试。

当通过以上URL进行访问时，其内部过程大概是：

- Spring Security的相关配置会进行URL的检查，来判断是否允许访问此路径
  - 所以，需要在`SecurityConfiguration`中将以上路径设置为白名单
  - 如果没有将以上路径配置到白名单，将直接跳转到登录页，因为默认所有请求都必须先登录
- 由`AdminController`接收到请求后，调用了`IAdminService`接口的实现类对象来处理登录
  - `IAdminService`接口的实现是`AdminServiceImpl`
- 在`AdminServiceImpl`中，调用了`AuthenticationManager`处理登录的认证
  - `AuthenticationManager`对象调用`authenticate()`方法进行登录处理
    - 内部实现中，会自动调用`UserDetailsService`实现对象的`loadUserByUsername()`方法以获取用户信息，并自动完成后续的认证处理（例如验证密码是否正确），所以，在步骤中，具体执行的是`UserDetailsServiceImpl`类中重写的方法，此方法返回了用户信息，Spring Security自动验证，如果失败（例如账号已禁用、密码错误等），会抛出异常
  - 以上调用的`authenticate()`方法如果未抛出异常，可视为认证成功，即登录成功
  - 当登录成功时，应该返回此用户的JWT数据（暂时未实现）

# 23.Spring Security + JWT

此前，在处理登录的业务中，当视为登录成功时，返回的字符串并不是JWT数据，则应该将此数据改为必要的JWT数据。

```java
@Service
public class AdminServiceImpl implements IAdminService {

   // ===== 原有其它代码 =====

    /**
     * JWT数据的密钥
     */
    private String secretKey = "fgfdsfadsfadsafdsafdsfadsfadsfdsafdasfdsafdsafdsafds4rttrefds";

    @Override
    public String login(AdminLoginDTO adminLoginDTO) {
        // ===== 原有其它代码 =====

        // 如果程序可以执行到此处，则表示登录成功
        // 生成此用户数据的JWT
        // Claims
        User user = (User) authenticate.getPrincipal();
        System.out.println("从认证结果中获取Principal=" + user.getClass().getName());
        Map<String, Object> claims = new HashMap<>();
        claims.put("username", user.getUsername());
        claims.put("permissions", user.getAuthorities());
        System.out.println("即将向JWT中写入数据=" + claims);

        // JWT的组成部分：Header（头），Payload（载荷），Signature（签名）
        String jwt = Jwts.builder()
                // Header：指定算法与当前数据类型
                // 格式为： { "alg": 算法, "typ": "jwt" }
                .setHeaderParam(Header.CONTENT_TYPE, "HS256")
                .setHeaderParam(Header.TYPE, Header.JWT_TYPE)
                // Payload：通常包含Claims（自定义数据）和过期时间
                .setClaims(claims)
                .setExpiration(new Date(System.currentTimeMillis() + 5 * 60 * 1000))
                // Signature：由算法和密钥（secret key）这2部分组成
                .signWith(SignatureAlgorithm.HS256, secretKey)
                // 打包生成
                .compact();

        // 返回JWT数据
        return jwt;
    }

}
```

在控制器中，应该响应JSON格式的数据，所以，需要在`mall-passport`中添加依赖`mall-common`。

将控制器中处理请求的方法的返回值类型改为`JsonResult<String>`，并调整返回值：

```java
// http://localhost:8080/admins/login?username=root&password=123456
@RequestMapping("/login")
public JsonResult<String> login(AdminLoginDTO adminLoginDTO) {
    String jwt = adminService.login(adminLoginDTO);
    return JsonResult.ok(jwt);
}
```



**注：**jdk版本为8，不然出现类型转换失败的异常



此时，重启项目，在浏览器中，使用正确的用户名和密码访问，响应的结果例如：

```json
{
    "state":20000,
    "message":null,
    "data":"eyJjdHkiOiJIUzI1NiIsInR5cCI6IkpXVCIsImFsZyI6IkhTMjU2In0.eyJwZXJtaXNzaW9ucyI6W3siYXV0aG9yaXR5IjoiL2Ftcy9hZG1pbi9kZWxldGUifSx7ImF1dGhvcml0eSI6Ii9hbXMvYWRtaW4vcmVhZCJ9LHsiYXV0aG9yaXR5IjoiL2Ftcy9hZG1pbi91cGRhdGUifSx7ImF1dGhvcml0eSI6Ii9wbXMvcHJvZHVjdC9kZWxldGUifSx7ImF1dGhvcml0eSI6Ii9wbXMvcHJvZHVjdC9yZWFkIn0seyJhdXRob3JpdHkiOiIvcG1zL3Byb2R1Y3QvdXBkYXRlIn1dLCJleHAiOjE2NTU0MzQwMzcsInVzZXJuYW1lIjoicm9vdCJ9.8ZIfpxxjJlwNo-E3JhXwH4sZR0J5-FU-HAOMu1Tg-44"
}
```

注意：以上只是访问`/admins/login`时会执行所编写的流程（发送用户名和密码，得到含JWT的结果），并不代表真正意义的实现了“登录”！

登录的流程应该是：客户端提交用户名和密码到服务器端 >>> 服务器端认证成功后响应JWT >>> 客户端在后续的请求中都携带JWT >>> 服务器端验证JWT来决定是否允许访问。

为了便于体现“客户端在后续的请求中都携带JWT”的操作，可以在项目中添加使用Knife4j。

当使用Knife4j时，需要在白名单中添加相关的放行资源路径，否则，Knife4j的页面将无法使用：

```java
@Configuration
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

    // ===== 原有其它代码 =====

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // ===== 原有其它代码 =====

        // URL白名单
        String[] urls = {
                "/admins/login",
                "/doc.html",  // 从本行开始，以下是新增
                "/**/*.js",
                "/**/*.css",
                "/swagger-resources",
                "/v2/api-docs",
                "/favicon.ico"
        };

        // ===== 原有其它代码 =====
    }
}
```

在后续的访问中，必须在请求中携带JWT数据， 服务器端才可以尝试解析此JWT数据，从而判断用户是否已登录或允许访问。

为了便于测试，在控制器中添加一个测试访问的请求配置：

```java
// 以下是测试访问的请求
@GetMapping("/hello")
public String sayHello() {
    return "hello~~~";
}
```

由于以上 `/admins/hello` 路径并不在白名单中，如果直接访问，会出现403错误。

在规范的使用方式中，JWT数据必须携带在请求头（Request Header）的`Authorization`属性中。

按照以上规范，则服务器端在**每次接收到请求**后，首先，就应该**先**判断请求头中是否存在`Authorization`、`Authorization`的值是否有效等操作，通常，是通过**过滤器**来实现以上检查的。

在`mall-passport`的根包下的`security`包下创建`JwtAuthenticationFilter`过滤器类，需要继承自`OncePerRequestFilter`类：

```java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        System.out.println("JwtAuthenticationFilter.doFilterInternal()");
    }

}
```

所有的过滤器都必须注册后才可以使用，且同一个项目中允许存在多个过滤器，形成过滤器链，以上用于验证JWT的过滤器应该运行在Spring Security处理登录的过滤器之前，需要在自定义的`SecurityConfiguration`中的`configure()`方法中将以上自定义的过滤器注册在Spring Security的相关过滤器之前：

```java
@Configuration
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

    // 新增
    @Autowired
    private JwtAuthenticationFilter jwtAuthenticationFilter;
    
    // ===== 原有其它代码 =====

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // ===== 原有其它代码 =====

        // 注册处理JWT的过滤器
        // 此过滤器必须在Spring Security处理登录的过滤器之前
        http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
    }
}
```

完成后，重启项目，无论对哪个路径发出请求，在控制台都可以看出输出了过滤器中的输出语句内容，并且，在浏览器将显示一片空白。

关于`JwtAuthenticationFilter`，它需要实现：

- 尝试从请求头中获取JWT数据
  - 如果无JWT数据，应该直接放行，Spring Security还会进行后续的处理，例如白名单的请求将允许访问，其它请求将禁止访问
- 如果存在JWT数据，应该尝试解析
  - 如果解析失败，应该视为错误，可以要求客户端重新登录，客户端就可以得到新的、正确的JWT，客户端在下一次提交请求时，使用新的JWT即可正确访问
- 将解析得到的数据封装到`Authentication`对象中
  - Spring Security的上下文中存储的数据类型是`Authentication`类型
- 为避免存入1次后，Spring Security的上下文中始终存在`Authentication`，在此过滤器执行的第一时间，应该清除上下文中的数据

```java
package cn.org.sqx.mall.passport.security;

import cn.org.sqx.mall.common.web.JsonResult;
import cn.org.sqx.mall.common.web.State;
import com.alibaba.fastjson.JSON;
import io.jsonwebtoken.*;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

/**
 * JWT过滤器：从请求头的Authorization中获取JWT中存入的用户信息
 * 并添加到Spring Security的上下文中
 * 以致于Spring Security后续的组件（包括过滤器等）能从上下文中获取此用户的信息
 * 从而验证是否已经登录、是否具有权限等
 */
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    /**
     * JWT数据的密钥
     */
    private String secretKey = "fgfdsfadsfadsafdsafdsfadsfadsfdsafdasfdsafdsafdsafds4rttrefds";

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        System.out.println("JwtAuthenticationFilter.doFilterInternal()");
        // 清除Spring Security上下文中的数据
        // 避免此前曾经存入过用户信息，后续即使没有携带JWT，在Spring Security仍保存有上下文数据（包括用户信息）
        System.out.println("清除Spring Security上下文中的数据");
        SecurityContextHolder.clearContext();
        // 客户端提交请求时，必须在请求头的Authorization中添加JWT数据，这是当前服务器程序的规定，客户端必须遵守
        // 尝试获取JWT数据
        String jwt = request.getHeader("Authorization");
        System.out.println("从请求头中获取到的JWT=" + jwt);
        // 判断是否不存在jwt数据
        if (!StringUtils.hasText(jwt)) {
            // 不存在jwt数据，则放行，后续还有其它过滤器及相关组件进行其它的处理，例如未登录则要求登录等
            // 此处不宜直接阻止运行，因为“登录”、“注册”等请求本应该没有jwt数据
            System.out.println("请求头中无JWT数据，当前过滤器将放行");
            filterChain.doFilter(request, response); // 继续执行过滤器链中后续的过滤器
            return; // 必须
        }

        // 注意：此时执行时，如果请求头中携带了Authentication，日志中将输出，且不会有任何响应，因为当前过滤器尚未放行
        // 以下代码有可能抛出异常的
        // TODO 密钥和各个Key应该统一定义
        String username = null;
        String permissionsString = null;
        try {
            System.out.println("请求头中包含JWT，准备解析此数据……");
            Claims claims = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(jwt).getBody();
            username = claims.get("username").toString();
            permissionsString = claims.get("permissions").toString();
            System.out.println("username=" + username);
            System.out.println("permissionsString=" + permissionsString);
        } catch (ExpiredJwtException e) {
            System.out.println("解析JWT失败，此JWT已过期：" + e.getMessage());
            JsonResult<Void> jsonResult = JsonResult.fail(
                    State.ERR_JWT_EXPIRED, "您的登录已过期，请重新登录！");
            String jsonString = JSON.toJSONString(jsonResult);
            System.out.println("响应结果：" + jsonString);
            response.setContentType("application/json; charset=utf-8");
            response.getWriter().println(jsonString);
            return;
        } catch (MalformedJwtException e) {
            System.out.println("解析JWT失败，此JWT数据错误，无法解析：" + e.getMessage());
            JsonResult<Void> jsonResult = JsonResult.fail(
                    State.ERR_JWT_MALFORMED, "获取登录信息失败，请重新登录！");
            String jsonString = JSON.toJSONString(jsonResult);
            System.out.println("响应结果：" + jsonString);
            response.setContentType("application/json; charset=utf-8");
            response.getWriter().println(jsonString);
            return;
        } catch (SignatureException e) {
            System.out.println("解析JWT失败，此JWT签名错误：" + e.getMessage());
            JsonResult<Void> jsonResult = JsonResult.fail(
                    State.ERR_JWT_SIGNATURE, "获取登录信息失败，请重新登录！");
            String jsonString = JSON.toJSONString(jsonResult);
            System.out.println("响应结果：" + jsonString);
            response.setContentType("application/json; charset=utf-8");
            response.getWriter().println(jsonString);
            return;
        } catch (Throwable e) {
            System.out.println("解析JWT失败，异常类型：" + e.getClass().getName());
            e.printStackTrace();
            JsonResult<Void> jsonResult = JsonResult.fail(
                    State.ERR_INTERNAL_SERVER_ERROR, "获取登录信息失败，请重新登录！");
            String jsonString = JSON.toJSONString(jsonResult);
            System.out.println("响应结果：" + jsonString);
            response.setContentType("application/json; charset=utf-8");
            response.getWriter().println(jsonString);
            return;
        }

        // 将此前从JWT中读取到的permissionsString（JSON字符串）转换成Collection<? extends GrantedAuthority>
        List<SimpleGrantedAuthority> permissions
                = JSON.parseArray(permissionsString, SimpleGrantedAuthority.class);
        System.out.println("从JWT中获取到的权限转换成Spring Security要求的类型：" + permissions);
        // 将解析得到的用户信息传递给Spring Security
        // 获取Spring Security的上下文，并将Authentication放到上下文中
        // 在Authentication中封装：用户名、null（密码）、权限列表
        // 因为接下来并不会处理认证，所以Authentication中不需要密码
        // 后续，Spring Security发现上下文中有Authentication时，就会视为已登录，甚至可以获取相关信息
        Authentication authentication
                = new UsernamePasswordAuthenticationToken(username, null, permissions);
        SecurityContextHolder.getContext().setAuthentication(authentication);
        System.out.println("将解析得到的用户信息传递给Spring Security");
        // 放行
        System.out.println("JwtAuthenticationFilter 放行");
        filterChain.doFilter(request, response);
    }

}
```

要使用Spring Security实现授权访问，首先，必须保证用户登录后，在Spring Security上下文中存在权限相关信息（目前，此项已完成，在`JwtAuthenticationFilter`的最后，已经存入权限信息）。

然后，需要在配置类上使用`@EnableGlobalMethodSecurity`注解开启“通过注解配置权限”的功能，所以，在`SecrutiyConfiguration`类上添加：

```java
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true) // 新增
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
    // ===== 类中原有代码 =====
}
```

最后，在任何你需要设置权限的处理请求的方法上，通过`@PreAuthorize`注解来配置要求某种权限，例如：

```java
@GetMapping("/hello")
@PreAuthorize("hasAuthority('/ams/admin/read')") // 新增
public String sayHello() {
    return "hello~~~";
}
```

完成后，重启项目，使用具有`/ams/admin/read`权限的用户可以直接访问，不具有此权限的用户则不能访问（将出现403）。













































